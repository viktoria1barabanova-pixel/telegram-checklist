/***************
 * CONFIG
 ***************/
const SHEET_NAMES = {
  sections: "Разделы",
  checklist: "Вопросы",
  branches: "Адреса",
  roll_weights: "Вес роллов",
  inspectors: "Проверяющие",
  submissions: "Результаты",
  answers: "Ответы",
  log: "Log",
};

// IMPORTANT: set this to the ID of the Google Spreadsheet that contains your questions
const SPREADSHEET_ID = "1Ln_cnU64l1NZRIDk2iAInkcFM1ACf6_2aiwqz7X8caw";

// Telegram Bot (for sending messages after submit)
// Set your bot token here. Without it, sendMessage will be skipped.
const TELEGRAM_BOT_TOKEN = "";

// Заголовки для листов с результатами
const SUBMISSIONS_HEADERS = [
  "submission_id",
  "submitted_at",
  "fio",
  "city",
  "branch_id",
  "branch_name",
  "zone",
  "inspection_area",
  "percent",
  "earned",
  "max_score",
  "tg_user_id",
  "meta_json",
];

const ANSWERS_HEADERS = [
  "submission_id",
  "submitted_at",
  "fio",
  "city",
  "branch_id",
  "branch_name",
  "section_code",
  "section_title",
  "question_id",
  "critikal",
  "question_text",
  "severity",
  "answer_key",
  "answer_text",
  "score_earned",
  "score_max",
  "comment",
  "photos_json",
];

const INSPECTORS_HEADERS = [
  "tg_user_id",
  "fio",
  "tg_username",
  "tg_first_name",
  "tg_last_name",
  "tg_name",
  "updated_at",
];

// Зоны (настройки теперь задаются в коде, без листа "Настройки")
const SETTINGS = {
  block_green_if_critical: true,
  yellow_zone_max_percent: 80,
  red_zone_max_percent: 70,
  grey_zone_max_percent: "",
};

const MY_SUBMISSIONS_DEFAULT_LIMIT = 200;

/***************
 * GET (data API)
 ***************/
function doGet(e) {
  try {
    const action = e?.parameter?.action ? String(e.parameter.action) : "all";
    const callback = e?.parameter?.callback ? String(e.parameter.callback) : null;
    if (action === "ping") {
      return output_({ ok: true, action: "ping", ts: new Date().toISOString() }, callback);
    }
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);

    let payload;
    if (action === "all") {
      payload = {
        sections: readSheetAsObjects_(ss, SHEET_NAMES.sections),
        checklist: readSheetAsObjects_(ss, SHEET_NAMES.checklist),
        branches: readSheetAsObjects_(ss, SHEET_NAMES.branches),
        roll_weights: readSheetAsObjects_(ss, SHEET_NAMES.roll_weights),
        settings: SETTINGS,
        meta: { updatedAt: new Date().toISOString() },
      };
    } else if (action === "sections") payload = readSheetAsObjects_(ss, SHEET_NAMES.sections);
    else if (action === "checklist") payload = readSheetAsObjects_(ss, SHEET_NAMES.checklist);
    else if (action === "branches") payload = readSheetAsObjects_(ss, SHEET_NAMES.branches);
    else if (action === "settings") payload = SETTINGS;
    else if (action === "my_submissions") {
      const tgUserId = e?.parameter?.tg_user_id ? String(e.parameter.tg_user_id).trim() : "";
      const limitRaw = e?.parameter?.limit ? String(e.parameter.limit).trim() : "";
      payload = getMySubmissionsPayload_(ss, tgUserId, limitRaw);
    }
    else if (action === "submission") {
      const submissionId = e?.parameter?.submission_id ? String(e.parameter.submission_id).trim() : "";
      payload = getSubmissionPayload_(ss, submissionId);
    }
    else payload = { error: "Unknown action", action };

    return output_(payload, callback);
  } catch (err) {
    return output_(
      { error: String(err), stack: err?.stack ?? null },
      e?.parameter?.callback ?? null
    );
  }
}

/***************
 * POST (submit answers)
 ***************/
function doPost(e) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);

  try {
    // железный лог: что реально прилетает
    const logSh = ss.getSheetByName(SHEET_NAMES.log) || ss.insertSheet(SHEET_NAMES.log);
    if (logSh.getLastRow() === 0) logSh.appendRow(["ts", "event", "data"]);
    logSh.appendRow([
      new Date().toISOString(),
      "doPost_hit",
      JSON.stringify({
        param: e && e.parameter ? e.parameter : null,
        postType: e && e.postData ? e.postData.type : null,
        postData: e && e.postData && e.postData.contents ? String(e.postData.contents).slice(0, 300) : ""
      })
    ]);
    logSh.appendRow([
      new Date().toISOString(),
      "target_spreadsheet",
      JSON.stringify({ id: ss.getId(), name: ss.getName() })
    ]);

    // Apps Script WebApp обычно кладёт form fields в e.parameter,
    // но на всякий случай поддержим e.postData.contents
    const params = (e && e.parameter) ? e.parameter : {};
    const action = params.action ? String(params.action) : "";

    const raw = extractPayloadFromPost_(e, params);
    if (!raw) throw new Error("Empty payload");

    const payload = JSON.parse(raw);

    if (action === "send_message") {
      const sendRes = sendTelegramMessageFromPayload_(ss, payload, { action });
      log_(ss, { event: "send_message", ok: sendRes.ok, info: sendRes.info || "" });
      return text_("OK");
    }

    if (action !== "submit") {
      log_(ss, { event: "post_unknown_action", action, params });
      return text_("OK");
    }

    // Обновляем/добавляем проверяющего
    try {
      upsertInspector_(ss, payload);
    } catch (inspectorErr) {
      log_(ss, { event: "inspector_upsert_error", error: String(inspectorErr) });
    }

    // Ensure output sheets exist & have headers
    const shSub = getOrCreateSheet_(ss, SHEET_NAMES.submissions, SUBMISSIONS_HEADERS);
    const shAns = getOrCreateSheet_(ss, SHEET_NAMES.answers, ANSWERS_HEADERS);

    // Prepare values (one submission row)
    const tg = payload.tg || {};
    const meta = payload.meta || {};
    const metaJson = payload.meta_json ? String(payload.meta_json) : "";
    const tgUserId = safe_(payload.tg_user_id || payload.tg_id || tg.user_id || tg.id);

    const subRow = [
      safe_(payload.submission_id),
      safe_(payload.submitted_at),
      safe_(payload.fio),
      safe_(payload.city),
      safe_(payload.branch_id),
      safe_(payload.branch_name),
      safe_(payload.zone),
      safe_(payload.inspection_area),
      safe_(payload.percent),
      safe_(payload.earned),
      safe_(payload.max_score),
      tgUserId,
      metaJson || json_(meta),
    ];

    shSub.appendRow(subRow);

    // Prepare answers rows (flat)
    const flat = Array.isArray(payload.answers_rows)
      ? payload.answers_rows
      : (Array.isArray(payload.answers_flat) ? payload.answers_flat : []);
    if (flat.length) {
      const rows = flat.map(a => ({
        submission_id: safe_(payload.submission_id),
        submitted_at: safe_(payload.submitted_at),
        fio: safe_(payload.fio),
        city: safe_(payload.city),
        branch_id: safe_(payload.branch_id),
        branch_name: safe_(payload.branch_name),
        section_code: safe_(a.section_code || a.section_id || ""),
        section_title: safe_(a.section_title),
        question_id: safe_(a.question_id),
        critikal: safe_(a.critikal || (String(a.severity || "").toLowerCase() === "critical" ? "critical" : "")),
        question_text: safe_(a.question_text),
        severity: safe_(a.severity),
        answer_key: safe_(a.answer_key || a.answer_value),
        answer_text: safe_(a.answer_text || a.answer_label),
        score_earned: safe_(a.score_earned),
        score_max: safe_(a.score_max),
        comment: safe_(a.comment),
        photos_json: json_(a.photos),
      }));

      appendObjectsRowsByHeaders_(shAns, rows);
    }

    const shouldSendTelegram = !payload.partial;
    const tgSendRes = shouldSendTelegram
      ? sendTelegramMessageFromPayload_(ss, payload, { action })
      : { ok: false, info: "skip_partial" };
    log_(ss, {
      event: "submit_ok",
      submission_id: payload.submission_id,
      answers: flat.length,
      tg_send_ok: tgSendRes.ok,
      tg_send_info: tgSendRes.info || "",
    });
    return text_("OK");

  } catch (err) {
    try {
      log_(ss, { event: "submit_error", error: String(err), stack: err && err.stack ? err.stack : "" });
    } catch (_) {}
    // Всё равно отдаём OK, чтобы iframe не ломал UX
    return text_("OK");
  }
}

/***************
 * Helpers
 ***************/
function output_(data, callback) {
  const json = JSON.stringify(data);

  // JSONP (обходит CORS)
  if (callback) {
    return ContentService
      .createTextOutput(`${callback}(${json});`)
      .setMimeType(ContentService.MimeType.JAVASCRIPT);
  }

  // обычный JSON
  return ContentService
    .createTextOutput(json)
    .setMimeType(ContentService.MimeType.JSON);
}

function text_(s) {
  return ContentService
    .createTextOutput(String(s))
    .setMimeType(ContentService.MimeType.TEXT);
}

function readSheetAsObjects_(ss, name) {
  const sh = ss.getSheetByName(name);
  if (!sh) return [];
  const values = sh.getDataRange().getValues();
  if (values.length < 2) return [];
  const headers = values[0].map(h => String(h).trim());

  return values.slice(1)
    .filter(r => r.some(cell => String(cell).trim() !== ""))
    .map(r => {
      const obj = {};
      headers.forEach((h, i) => obj[h] = r[i]);
      return obj;
    });
}

function readSheetAsKeyValue_(ss, name) {
  const sh = ss.getSheetByName(name);
  if (!sh) return {};
  const values = sh.getDataRange().getValues();
  const out = {};
  for (let i = 1; i < values.length; i++) {
    const key = String(values[i][0] ?? "").trim();
    if (key) out[key] = values[i][1];
  }
  return out;
}

function getOrCreateSheet_(ss, name, headers) {
  let sh = ss.getSheetByName(name);
  if (!sh) sh = ss.insertSheet(name);

  // Ensure header row exists and correct
  const lastCol = Math.max(sh.getLastColumn(), headers.length);
  const existing = sh.getRange(1, 1, 1, lastCol).getValues()[0].map(v => String(v || "").trim());

  const needRewrite =
    existing.slice(0, headers.length).join("|") !== headers.join("|");

  if (needRewrite) {
    sh.getRange(1, 1, 1, headers.length).setValues([headers]);
    sh.setFrozenRows(1);
  }

  return sh;
}

function log_(ss, obj) {
  const sh = getOrCreateSheet_(ss, SHEET_NAMES.log, ["ts", "event", "data"]);
  sh.appendRow([new Date().toISOString(), obj?.event || "", JSON.stringify(obj || {})]);
}

function safe_(v) {
  if (v === null || v === undefined) return "";
  // Apps Script любит boolean/number норм, оставим как есть
  return v;
}

function normalizeHeaderKey_(value) {
  return String(value || "")
    .trim()
    .toLowerCase()
    .replace(/[\s\-]+/g, "_")
    .replace(/[^a-zа-я0-9_]/g, "")
    .replace(/_+/g, "_")
    .replace(/^_+|_+$/g, "");
}

function json_(v) {
  if (v === null || v === undefined) return "";
  try { return JSON.stringify(v); } catch { return ""; }
}
function parseFormUrlEncoded_(s) {
  const out = {};
  String(s || "").split("&").forEach(pair => {
    const idx = pair.indexOf("=");
    const k = idx >= 0 ? pair.slice(0, idx) : pair;
    const v = idx >= 0 ? pair.slice(idx + 1) : "";
    if (!k) return;
    out[decodeURIComponent(k)] = decodeURIComponent(String(v || "").replace(/\+/g, " "));
  });
  return out;
}

function extractPayloadFromPost_(e, params) {
  let raw = params && params.payload ? String(params.payload) : "";
  if (!raw && e && e.postData && e.postData.contents) {
    const parsed = parseFormUrlEncoded_(String(e.postData.contents));
    raw = parsed.payload ? String(parsed.payload) : "";
  }
  return raw;
}

function sendTelegramMessageFromPayload_(ss, payload, { action } = {}) {
  if (!TELEGRAM_BOT_TOKEN) {
    return { ok: false, info: "bot_token_missing" };
  }

  const initData = safe_(payload?.init_data || payload?.initData || "");
  const tgUser = verifyInitData_(initData, TELEGRAM_BOT_TOKEN);
  if (!tgUser) {
    return { ok: false, info: "init_data_invalid" };
  }

  const chatId = tgUser.id;
  if (!chatId) {
    return { ok: false, info: "tg_user_id_missing" };
  }

  const text = buildTelegramMessageText_(payload, { action });
  if (!text) {
    return { ok: false, info: "message_text_empty" };
  }

  const sendRes = sendTelegramMessage_(chatId, text);
  return sendRes;
}

function buildTelegramMessageText_(payload, { action } = {}) {
  const direct = safe_(payload?.message_text || payload?.text || "");
  if (direct) return String(direct);

  const zoneRaw = String(payload?.zone || "").toLowerCase();
  const zoneText = (
    zoneRaw === "green" ? "зелёную зону" :
    zoneRaw === "yellow" ? "жёлтую зону" :
    zoneRaw === "red" ? "красную зону" :
    zoneRaw ? "серую зону" : ""
  );
  const link = safe_(payload?.result_link || payload?.link || "");

  let text = zoneText
    ? `Проверка завершена. Вы прошли на ${zoneText}.`
    : "Проверка завершена.";
  if (link) text += ` Ссылка на проверку: ${link}`;
  if (!text && action) text = `Проверка завершена (${action}).`;
  return text;
}

function sendTelegramMessage_(chatId, text) {
  const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
  const payload = {
    chat_id: chatId,
    text: String(text || ""),
    disable_web_page_preview: false,
  };

  try {
    const resp = UrlFetchApp.fetch(url, {
      method: "post",
      contentType: "application/json",
      payload: JSON.stringify(payload),
      muteHttpExceptions: true,
    });
    const status = resp.getResponseCode();
    const body = resp.getContentText();
    const ok = status >= 200 && status < 300;
    return { ok, info: ok ? "sent" : `status_${status}`, response: body };
  } catch (err) {
    return { ok: false, info: String(err) };
  }
}

function verifyInitData_(initData, botToken) {
  if (!initData || !botToken) return null;

  const data = parseInitData_(initData);
  if (!data || !data.hash) return null;

  const checkString = buildDataCheckString_(data);
  const secretKey = Utilities.computeHmacSha256Signature("WebAppData", botToken);
  const hash = Utilities.computeHmacSha256Signature(checkString, secretKey);
  const hex = bytesToHex_(hash);

  if (hex !== String(data.hash).toLowerCase()) return null;

  try {
    return data.user ? JSON.parse(data.user) : null;
  } catch (_) {
    return null;
  }
}

function parseInitData_(initData) {
  const out = {};
  String(initData || "").split("&").forEach(pair => {
    const idx = pair.indexOf("=");
    const key = idx >= 0 ? pair.slice(0, idx) : pair;
    const val = idx >= 0 ? pair.slice(idx + 1) : "";
    if (!key) return;
    out[decodeURIComponent(key)] = decodeURIComponent(String(val || "").replace(/\+/g, " "));
  });
  return out;
}

function buildDataCheckString_(data) {
  const keys = Object.keys(data || {}).filter(k => k !== "hash").sort();
  return keys.map(key => `${key}=${data[key]}`).join("\n");
}

function bytesToHex_(bytes) {
  return (bytes || [])
    .map(b => {
      const v = b < 0 ? b + 256 : b;
      return ("0" + v.toString(16)).slice(-2);
    })
    .join("");
}

/***************
 * Submission fetch helpers (for shareable result links)
 ***************/
function getMySubmissionsPayload_(ss, tgUserId, limitRaw) {
  const id = String(safe_(tgUserId)).trim();
  if (!id) return { ok: false, error: "No tg_user_id", items: [] };

  const sh = ss.getSheetByName(SHEET_NAMES.submissions);
  if (!sh) return { ok: true, tg_user_id: id, items: [], total: 0 };

  const values = sh.getDataRange().getValues();
  if (values.length < 2) return { ok: true, tg_user_id: id, items: [], total: 0 };

  const headers = values[0].map(h => String(h).trim());
  const normalizedHeaders = headers.map(normalizeHeaderKey_);
  const normalizedMap = {};
  normalizedHeaders.forEach((h, i) => { if (h) normalizedMap[h] = i; });

  const idCol = normalizedMap.tg_user_id ?? headers.indexOf("tg_user_id");
  if (idCol < 0) return { ok: false, error: "tg_user_id column missing", items: [] };

  const parsedLimit = Number.parseInt(String(limitRaw || ""), 10);
  const limit = Number.isFinite(parsedLimit) && parsedLimit > 0 ? parsedLimit : MY_SUBMISSIONS_DEFAULT_LIMIT;

  const items = [];
  let total = 0;

  for (let i = values.length - 1; i >= 1; i -= 1) {
    const rowId = String(safe_(values[i][idCol])).trim();
    if (!rowId || rowId !== id) continue;
    total += 1;
    if (items.length >= limit) continue;
    const obj = {};
    headers.forEach((h, j) => {
      const value = values[i][j];
      const normKey = normalizedHeaders[j];
      if (h) obj[h] = value;
      if (normKey && obj[normKey] === undefined) obj[normKey] = value;
    });
    items.push(obj);
  }

  return {
    ok: true,
    tg_user_id: id,
    total,
    items,
    meta: { updatedAt: new Date().toISOString() }
  };
}

function getSubmissionPayload_(ss, submissionId) {
  if (!submissionId) return { ok: false, error: "No submission_id" };

  const sub = findRowById_(ss.getSheetByName(SHEET_NAMES.submissions), "submission_id", submissionId);
  if (!sub) return { ok: false, error: "Submission not found", submission_id: submissionId };

  const answers = findRowsById_(ss.getSheetByName(SHEET_NAMES.answers), "submission_id", submissionId);
  const answersNormalized = normalizeAnswersRows_(answers);
  const issues = buildIssuesFromAnswerRows_(answersNormalized);

  return {
    ok: true,
    submission_id: submissionId,
    submission: sub,
    answers,
    answers_normalized: answersNormalized,
    issues,
    meta: { updatedAt: new Date().toISOString() }
  };
}

function normalizeAnswersRows_(rows) {
  return (rows || []).map(normalizeAnswerRow_);
}

function normalizeAnswerRow_(row) {
  const scoreEarned = toNumberOrEmpty_(row?.score_earned);
  const scoreMax = toNumberOrEmpty_(row?.score_max);
  const hasScores = scoreEarned !== "" && scoreMax !== "";
  const maxPositive = hasScores && Number(scoreMax) > 0;
  const isIssue = maxPositive ? Number(scoreEarned) < Number(scoreMax) : false;

  return {
    ...row,
    score_earned: scoreEarned,
    score_max: scoreMax,
    photos: parsePhotosJson_(row?.photos_json),
    is_issue: isIssue,
  };
}

function toNumberOrEmpty_(value) {
  if (value === "" || value === null || value === undefined) return "";
  const num = Number(String(value).replace(",", "."));
  return Number.isFinite(num) ? num : "";
}

function parsePhotosJson_(value) {
  const raw = safe_(value);
  if (!raw) return [];
  try {
    const parsed = JSON.parse(raw);
    if (Array.isArray(parsed)) return parsed.map(safe_).filter(Boolean);
  } catch (_) {}
  return [raw];
}

function buildIssuesFromAnswerRows_(rows) {
  const issues = [];
  (rows || []).forEach(row => {
    if (!row?.is_issue) return;
    issues.push({
      qid: safe_(row.question_id),
      title: safe_(row.question_text),
      sectionTitle: safe_(row.section_title),
      severity: safe_(row.severity) || "noncritical",
      score: row.score_earned,
      score_earned: row.score_earned,
      score_max: row.score_max,
      comment: safe_(row.comment),
      photos: row.photos || [],
    });
  });
  return issues;
}

function findRowById_(sh, idHeader, idValue) {
  if (!sh) return null;
  const values = sh.getDataRange().getValues();
  if (values.length < 2) return null;

  const headers = values[0].map(h => String(h).trim());
  const idCol = headers.indexOf(idHeader);
  if (idCol < 0) return null;

  for (let i = 1; i < values.length; i++) {
    if (String(values[i][idCol] || "").trim() === idValue) {
      const obj = {};
      headers.forEach((h, j) => obj[h] = values[i][j]);
      return obj;
    }
  }
  return null;
}

function findRowsById_(sh, idHeader, idValue) {
  if (!sh) return [];
  const values = sh.getDataRange().getValues();
  if (values.length < 2) return [];

  const headers = values[0].map(h => String(h).trim());
  const idCol = headers.indexOf(idHeader);
  if (idCol < 0) return [];

  const out = [];
  for (let i = 1; i < values.length; i++) {
    if (String(values[i][idCol] || "").trim() === idValue) {
      const obj = {};
      headers.forEach((h, j) => obj[h] = values[i][j]);
      out.push(obj);
    }
  }
  return out;
}

function getHeaderMap_(sh) {
  const lastCol = sh.getLastColumn();
  if (lastCol === 0) return {};
  const headers = sh.getRange(1, 1, 1, lastCol).getValues()[0]
    .map(h => String(h || "").trim());
  const map = {};
  headers.forEach((h, i) => { if (h) map[h] = i + 1; }); // 1-based
  return map;
}

function appendObjectRowByHeaders_(sh, obj) {
  const map = getHeaderMap_(sh);
  const lastCol = sh.getLastColumn();
  const row = new Array(lastCol).fill("");

  Object.keys(obj || {}).forEach(key => {
    const col = map[key];
    if (col) row[col - 1] = obj[key];
  });

  sh.appendRow(row);
}

function appendObjectsRowsByHeaders_(sh, objects) {
  if (!objects || !objects.length) return;

  const map = getHeaderMap_(sh);
  const lastCol = sh.getLastColumn();

  const rows = objects.map(obj => {
    const row = new Array(lastCol).fill("");
    Object.keys(obj || {}).forEach(key => {
      const col = map[key];
      if (col) row[col - 1] = obj[key];
    });
    return row;
  });

  sh.getRange(sh.getLastRow() + 1, 1, rows.length, lastCol).setValues(rows);
}

function upsertInspector_(ss, payload) {
  const sh = getOrCreateSheet_(ss, SHEET_NAMES.inspectors, INSPECTORS_HEADERS);

  const tg = payload.tg || {};
  const tgUserId = safe_(payload.tg_user_id || payload.tg_id || tg.user_id || tg.id);
  const fio = safe_(payload.fio || payload.tg_name || tg.name || "");

  if (!tgUserId) return;

  const now = new Date().toISOString();
  const headerMap = getHeaderMap_(sh);

  const idCol = headerMap["tg_user_id"];
  if (!idCol) return;

  const lastRow = sh.getLastRow();
  let foundRow = 0;

  if (lastRow >= 2) {
    const ids = sh.getRange(2, idCol, lastRow - 1, 1).getValues();
    for (let i = 0; i < ids.length; i++) {
      if (String(ids[i][0] || "").trim() === String(tgUserId).trim()) {
        foundRow = i + 2;
        break;
      }
    }
  }

  const record = {
    tg_user_id: tgUserId,
    fio: fio,
    tg_username: safe_(payload.tg_username || tg.username),
    tg_first_name: safe_(payload.tg_first_name || tg.first_name),
    tg_last_name: safe_(payload.tg_last_name || tg.last_name),
    tg_name: safe_(payload.tg_name || tg.name || [tg.first_name, tg.last_name].filter(Boolean).join(" ").trim()),
    updated_at: now,
  };

  if (!foundRow) {
    appendObjectRowByHeaders_(sh, record);
  } else {
    const lastCol = sh.getLastColumn();
    const existingVals = sh.getRange(foundRow, 1, 1, lastCol).getValues()[0];
    const existing = {};
    Object.keys(headerMap).forEach(key => {
      const col = headerMap[key];
      existing[key] = col ? existingVals[col - 1] : "";
    });

    let changed = false;
    Object.keys(record).forEach(key => {
      if (key === "updated_at") return;
      const col = headerMap[key];
      if (!col) return;

      const nextVal = record[key];
      if (nextVal === "" || nextVal === null || nextVal === undefined) return;

      const prevVal = existing[key];
      if (String(prevVal ?? "") === String(nextVal ?? "")) return;

      sh.getRange(foundRow, col).setValue(nextVal);
      changed = true;
    });

    if (changed && headerMap.updated_at) {
      sh.getRange(foundRow, headerMap.updated_at).setValue(now);
    }
  }
}
