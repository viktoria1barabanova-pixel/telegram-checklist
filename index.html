<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Checklist</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root { --pad: 14px; --danger:#ff4d4f; --dangerBg:#fff1f0; }
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; margin: 0; padding: var(--pad); background:#fff; }
    h1 { font-size: 20px; margin: 0 0 10px; }
    h2 { font-size: 16px; margin: 16px 0 10px; }
    .muted { color: #666; }
    .card { border: 1px solid #e7e7e7; border-radius: 14px; padding: 12px; margin: 10px 0; background: #fff; }
    .card.error { border: 2px solid var(--danger); background: var(--dangerBg); }
    .row { display: grid; gap: 10px; }
    label { font-size: 12px; color: #666; }
    select, button { width: 100%; padding: 12px; border-radius: 12px; border: 1px solid #ddd; font-size: 16px; background: #fff; }
    button { border: none; background: #111; color: #fff; cursor: pointer; }
    button:disabled { background: #bbb; cursor: not-allowed; }
    .btnSecondary { background:#fff; color:#111; border:1px solid #ddd; }
    .tabs { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 6px; margin: 10px 0; }
    .tab { padding: 10px 12px; border-radius: 999px; border: 1px solid #ddd; background: #fff; white-space: nowrap; cursor: pointer; }
    .tab.active { background: #111; color: #fff; border-color: #111; }
    .pill { display:inline-block; padding: 6px 10px; border-radius: 999px; background:#f2f2f2; font-size: 12px; }
    .hr { height: 1px; background: #eee; margin: 12px 0; }

    .q-title { font-weight: 800; margin-bottom: 6px; }
    .q-desc { font-size: 13px; color: #666; margin-bottom: 10px; }
    .opt { display:flex; align-items:flex-start; gap:10px; padding: 10px; border-radius: 12px; border: 1px solid #eee; margin-top: 8px; }
    .opt input { margin-top: 3px; }
    .groupTitle { font-weight: 900; margin: 14px 0 8px; }

    .topbar { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .progress { font-size: 12px; color:#666; }
    .warn { color: var(--danger); font-weight: 700; }
  </style>
</head>
<body>
  <div id="app" class="muted">Загружаю данные…</div>

  <script>
    // ====== 1) ПОДСТАВЬ СВОЙ URL (googleusercontent) ======
    const DATA_URL = "https://script.google.com/macros/s/AKfycbx-yZVSUsNaNKqNv_bJ8IFHgJ49vgJ3hK4qT4OI7nDKkyjXun1R1npEwxHbbs5M0UawSQ/exec";

    // ====== ZONE THRESHOLDS (percent) ======
    const ZONE_RED_MAX = 70;    // 0..70 => red
    const ZONE_YELLOW_MAX = 85; // 70..85 => yellow

    // ====== UTILS ======
    const appEl = document.getElementById("app");
    const norm = (v) => (v ?? "").toString().trim();
    const toBool = (v) => v === true || v === "TRUE" || v === "true" || v === 1 || v === "1";
    const escapeHtml = (s) => String(s).replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
    const uniq = (arr) => [...new Set(arr)];

    function render(html) { appEl.innerHTML = html; }

    function renderError(title, err) {
      render(`
        <h1>${escapeHtml(title)}</h1>
        <div class="card">
          <div class="muted">Скинь мне этот текст — быстро разрулю.</div>
          <div class="hr"></div>
          <pre style="white-space:pre-wrap">${escapeHtml(String(err?.stack || err))}</pre>
        </div>
      `);
    }

    // ====== STATE ======
    let DATA = null;

    const STATE = {
      city: "",
      branchId: "",
      enabledSections: [],
      activeSection: "",
      // answers
      singleAnswers: {},   // key: section_code|question_id -> "ideal" | "acceptable" | "bad"
      checkboxAnswers: {}, // key: groupKey -> Set(itemId)
    };

    function draftKey() { return `draft_v2_${STATE.branchId || "no_branch"}`; }

    function saveDraft() {
      try {
        const serialCheckbox = {};
        for (const [k, set] of Object.entries(STATE.checkboxAnswers)) serialCheckbox[k] = [...set];
        localStorage.setItem(draftKey(), JSON.stringify({
          city: STATE.city,
          branchId: STATE.branchId,
          enabledSections: STATE.enabledSections,
          activeSection: STATE.activeSection,
          singleAnswers: STATE.singleAnswers,
          checkboxAnswers: serialCheckbox,
          savedAt: Date.now()
        }));
      } catch {}
    }

    function loadDraft(branchId) {
      try {
        const raw = localStorage.getItem(`draft_v2_${branchId}`);
        if (!raw) return null;
        const d = JSON.parse(raw);
        // restore Sets
        const restored = {};
        for (const [k, arr] of Object.entries(d.checkboxAnswers || {})) restored[k] = new Set(arr);
        d.checkboxAnswers = restored;
        return d;
      } catch { return null; }
    }

    // ====== DATA ADAPTER (твой формат таблицы) ======
    // ожидаем DATA.checklist строки с колонками:
    // section_code, question_id, question_text, question_description, question_type,
    // ideal_answer, acceptable_answer, bad_answer, score, severity, exclude_from_max, active, sort_order

    function getActiveSections() {
      return (DATA.sections || [])
        .filter(s => toBool(s.active) && norm(s.section_code))
        .sort((a,b) => Number(a.sort_order||0) - Number(b.sort_order||0));
    }

    function sectionsByCode() {
      const m = new Map();
      for (const s of getActiveSections()) m.set(norm(s.section_code), s);
      return m;
    }

    function getActiveBranches() {
      return (DATA.branches || [])
        .filter(b => toBool(b.active) && norm(b.city) && norm(b.branch_id) && norm(b.branch_name));
    }

    function getChecklistRows() {
      return (DATA.checklist || [])
        .filter(r => toBool(r.active) && norm(r.section_code) && norm(r.question_id) && norm(r.question_type));
    }

    function enabledSectionsFromBranch(branch) {
      const raw = norm(branch.enabled_sections_default);
      if (!raw) return [];
      return raw.split(",").map(s => s.trim()).filter(Boolean);
    }

    // SINGLE questions: group by section_code + question_id
    function buildSingles(rows, enabledSections) {
      const m = {}; // sec -> [{...}]
      for (const r of rows) {
        const type = norm(r.question_type).toLowerCase();
        if (type !== "single" && type !== "radio") continue;
        const sec = norm(r.section_code);
        if (!enabledSections.includes(sec)) continue;

        const key = `${sec}|${norm(r.question_id)}`;
        m[sec] ??= [];
        // one row per single question (в твоей таблице это 1 строка)
        m[sec].push({
          key,
          section_code: sec,
          question_id: norm(r.question_id),
          question_text: norm(r.question_text),
          question_description: norm(r.question_description),
          ideal_answer: norm(r.ideal_answer),
          acceptable_answer: norm(r.acceptable_answer),
          bad_answer: norm(r.bad_answer),
          score: Number(r.score || 0),
          severity: norm(r.severity),
          exclude_from_max: toBool(r.exclude_from_max),
          sort_order: Number(r.sort_order || 0)
        });
      }
      for (const sec of Object.keys(m)) {
        m[sec].sort((a,b)=>a.sort_order-b.sort_order || a.question_id.localeCompare(b.question_id));
      }
      return m;
    }

    // CHECKBOX groups: group by section_code + question_description
    // group title = question_description, item text = question_text, item id = question_id
    function buildCheckboxGroups(rows, enabledSections) {
      const m = {}; // sec -> [group]
      const tmp = {}; // groupKey -> group
      for (const r of rows) {
        const type = norm(r.question_type).toLowerCase();
        if (type !== "checkbox") continue;
        const sec = norm(r.section_code);
        if (!enabledSections.includes(sec)) continue;

        const title = norm(r.question_description) || "Чек-лист";
        const groupKey = `${sec}||${title}`;

        tmp[groupKey] ??= {
          groupKey,
          section_code: sec,
          title,
          sort_order: Number(r.sort_order || 0),
          items: []
        };

        tmp[groupKey].items.push({
          item_id: norm(r.question_id),
          text: norm(r.question_text),
          score: Number(r.score || 0),
          severity: norm(r.severity),
          exclude_from_max: toBool(r.exclude_from_max),
          // трактуем как "идеал = TRUE, стрём = FALSE"
          ideal_value: norm(r.ideal_answer).toUpperCase() === "TRUE",
          bad_value: norm(r.bad_answer).toUpperCase() === "FALSE"
        });
      }

      for (const g of Object.values(tmp)) {
        // sort items by sort_order? в твоей таблице sort_order общий — оставим по item_id если нет
        g.items.sort((a,b)=>a.item_id.localeCompare(b.item_id));
        m[g.section_code] ??= [];
        m[g.section_code].push(g);
      }

      for (const sec of Object.keys(m)) {
        m[sec].sort((a,b)=>a.sort_order-b.sort_order || a.title.localeCompare(b.title));
      }
      return m;
    }

    // ====== VALIDATION ======
    function validateAll(singlesBySec, checkboxGroupsBySec, enabledSections) {
      const sectionMap = sectionsByCode();

      const missingSingles = new Set();     // keys of single questions
      const missingSections = new Set();

      // singles
      for (const sec of enabledSections) {
        for (const q of (singlesBySec[sec] || [])) {
          if (!STATE.singleAnswers[q.key]) {
            missingSingles.add(q.key);
            missingSections.add(sec);
          }
        }
      }

      const missingSectionTitles = [...missingSections].map(code => {
        const s = sectionMap.get(code);
        return s ? norm(s.title) : code;
      });

      return {
        ok: missingSingles.size === 0,
        missingSingles,
        missingSections,
        missingSectionTitles
      };
    }

    // ====== RESULTS (итог / зона / ошибки) ======
    function computeResult(rows, singlesBySec, checkboxGroupsBySec, enabledSections) {
      let earned = 0;
      let maxScore = 0;

      const issuesBySection = {}; // sec -> array of strings
      const addIssue = (sec, text) => {
        issuesBySection[sec] ??= [];
        issuesBySection[sec].push(text);
      };

      // SINGLE scoring
      for (const sec of enabledSections) {
        for (const q of (singlesBySec[sec] || [])) {
          if (!q.exclude_from_max) maxScore += Number(q.score || 0);

          const sel = STATE.singleAnswers[q.key];
          if (!sel) continue;

          if (sel === "ideal") {
            earned += Number(q.score || 0);
          } else if (sel === "acceptable") {
            earned += Number(q.score || 0) / 2;
            addIssue(sec, `${q.question_text}: ${q.acceptable_answer}`);
          } else if (sel === "bad") {
            addIssue(sec, `${q.question_text}: ${q.bad_answer}`);
          }
        }
      }

      // CHECKBOX scoring (checked items add points; unchecked are treated as issues)
      for (const sec of enabledSections) {
        for (const g of (checkboxGroupsBySec[sec] || [])) {
          const set = STATE.checkboxAnswers[g.groupKey] || new Set();

          for (const it of (g.items || [])) {
            if (!it.exclude_from_max) maxScore += Number(it.score || 0);

            if (set.has(it.item_id)) {
              earned += Number(it.score || 0);
            } else {
              addIssue(sec, `${g.title}: нет «${it.text}»`);
            }
          }
        }
      }

      const percent = maxScore > 0 ? Math.round((earned / maxScore) * 1000) / 10 : 0;
      let zone = "green";
      if (percent <= ZONE_RED_MAX) zone = "red";
      else if (percent <= ZONE_YELLOW_MAX) zone = "yellow";

      return { earned, maxScore, percent, zone, issuesBySection };
    }

    function zoneLabel(zone) {
      if (zone === "red") return "КРАСНАЯ ЗОНА";
      if (zone === "yellow") return "ЖЁЛТАЯ ЗОНА";
      return "ЗЕЛЁНАЯ ЗОНА";
    }

    function renderResultScreen(result, branch) {
      const sectionMap = sectionsByCode();
      const secTitle = (code) => {
        const s = sectionMap.get(code);
        return s ? norm(s.title) : code;
      };

      const issuesSections = Object.keys(result.issuesBySection || {});

      render(`
        <h1>Итог</h1>
        <div class="muted">
          <span class="pill">${escapeHtml(norm(branch?.city || STATE.city))}</span>
          <span class="pill">${escapeHtml(norm(branch?.branch_name || STATE.branchId))}</span>
        </div>

        <div class="card" style="border:none;padding:0">
          <div class="pill" style="display:inline-block;margin-top:10px;font-weight:900">
            ${escapeHtml(zoneLabel(result.zone))}
          </div>
          <div style="margin-top:8px;font-size:18px;font-weight:900">
            ${escapeHtml(result.earned)} / ${escapeHtml(result.maxScore)} • ${escapeHtml(result.percent)}%
          </div>
        </div>

        <div class="card">
          <h2 style="margin-top:0">Где есть ошибки</h2>
          ${issuesSections.length ? issuesSections.map(sec => `
            <div style="margin-top:12px">
              <div style="font-weight:900">${escapeHtml(secTitle(sec))}</div>
              <div class="muted" style="font-size:12px;margin-top:6px">
                ${(result.issuesBySection[sec] || []).map(x => `• ${escapeHtml(x)}`).join('<br/>')}
              </div>
            </div>
          `).join('') : `<div class="muted">Ошибок нет ✅</div>`}
        </div>

        <div class="card">
          <button id="backToForm">Вернуться к опроснику</button>
          <button id="backToStart" class="btnSecondary" style="margin-top:8px">Новая проверка</button>
        </div>
      `);

      document.getElementById("backToForm").onclick = () => renderSurvey();
      document.getElementById("backToStart").onclick = () => renderStart();
    }

    // ====== UI: START ======
    function renderStart() {
      const branches = getActiveBranches();
      const cities = uniq(branches.map(b => norm(b.city))).sort();

      render(`
        <h1>Проверка филиала</h1>
        <div class="card">
          <div class="row">
            <div>
              <label>Город</label>
              <select id="city">
                <option value="">Выбери город</option>
                ${cities.map(c => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join("")}
              </select>
            </div>

            <div>
              <label>Филиал</label>
              <select id="branch" disabled>
                <option value="">Сначала выбери город</option>
              </select>
            </div>

            <button id="go" disabled>Начать</button>
          </div>
        </div>
        <div class="muted">Все вопросы обязательные ✅</div>
      `);

      const citySel = document.getElementById("city");
      const branchSel = document.getElementById("branch");
      const goBtn = document.getElementById("go");

      citySel.addEventListener("change", () => {
        const city = citySel.value;
        const list = branches.filter(b => norm(b.city) === norm(city));
        branchSel.innerHTML = `<option value="">Выбери филиал</option>` + list
          .map(b => `<option value="${escapeHtml(norm(b.branch_id))}">${escapeHtml(norm(b.branch_name))}</option>`)
          .join("");
        branchSel.disabled = false;
        goBtn.disabled = true;
      });

      branchSel.addEventListener("change", () => {
        goBtn.disabled = !branchSel.value;
      });

      goBtn.addEventListener("click", () => {
        STATE.city = citySel.value;
        STATE.branchId = branchSel.value;

        const branch = getActiveBranches().find(b => norm(b.branch_id) === norm(STATE.branchId));
        const defaults = branch ? enabledSectionsFromBranch(branch) : [];
        const allSections = getActiveSections().map(s => norm(s.section_code));
        STATE.enabledSections = defaults.length ? defaults : allSections;

        // load draft if exists
        const d = loadDraft(STATE.branchId);
        if (d) {
          STATE.enabledSections = d.enabledSections?.length ? d.enabledSections : STATE.enabledSections;
          STATE.activeSection = d.activeSection || "";
          STATE.singleAnswers = d.singleAnswers || {};
          STATE.checkboxAnswers = d.checkboxAnswers || {};
        }

        // set active section
        if (!STATE.activeSection || !STATE.enabledSections.includes(STATE.activeSection)) {
          STATE.activeSection = STATE.enabledSections[0];
        }

        saveDraft();
        renderSurvey();
      });
    }

    // ====== UI: SURVEY ======
    function renderSurvey() {
      const branch = getActiveBranches().find(b => norm(b.branch_id) === norm(STATE.branchId));
      const sectionMap = sectionsByCode();

      const rows = getChecklistRows();
      const singlesBySec = buildSingles(rows, STATE.enabledSections);
      const checkboxGroupsBySec = buildCheckboxGroups(rows, STATE.enabledSections);

      function sectionTitle(code) {
        const s = sectionMap.get(code);
        return s ? norm(s.title) : code;
      }

      function renderTabs() {
        return `
          <div class="tabs">
            ${STATE.enabledSections.map(code => {
              const active = code === STATE.activeSection ? "active" : "";
              return `<div class="tab ${active}" data-sec="${escapeHtml(code)}">${escapeHtml(sectionTitle(code))}</div>`;
            }).join("")}
          </div>
        `;
      }

      function renderActiveSectionContent() {
        const sec = STATE.activeSection;
        const singles = singlesBySec[sec] || [];
        const groups = checkboxGroupsBySec[sec] || [];

        let html = "";

        // SINGLE QUESTIONS
        for (const q of singles) {
          const selected = STATE.singleAnswers[q.key] || "";
          html += `
            <div class="card question" data-single-key="${escapeHtml(q.key)}">
              <div class="q-title">${escapeHtml(q.question_text || q.question_id)}</div>
              ${q.question_description ? `<div class="q-desc">${escapeHtml(q.question_description)}</div>` : ""}
              ${(() => {
                const opts = [
                  { value: "ideal", text: norm(q.ideal_answer) },
                  { value: "acceptable", text: norm(q.acceptable_answer) },
                  { value: "bad", text: norm(q.bad_answer) }
                ].filter(o => o.text);

                // If the previously selected value no longer exists (e.g., acceptable removed), clear it
                const allowed = new Set(opts.map(o => o.value));
                if (selected && !allowed.has(selected)) {
                  delete STATE.singleAnswers[q.key];
                  saveDraft();
                }

                const selectedNow = STATE.singleAnswers[q.key] || "";

                return opts.map(opt => `
                  <label class="opt">
                    <input type="radio" name="s_${escapeHtml(q.key)}" value="${escapeHtml(opt.value)}" ${selectedNow===opt.value?"checked":""}/>
                    <div style="flex:1">
                      <div>${escapeHtml(opt.text)}</div>
                    </div>
                  </label>
                `).join("");
              })()}
            </div>
          `;
        }

        // CHECKBOX GROUPS
        for (const g of groups) {
          const set = STATE.checkboxAnswers[g.groupKey] || new Set();

          html += `
            <div class="card question" data-group-key="${escapeHtml(g.groupKey)}">
              <div class="groupTitle">${escapeHtml(g.title)}</div>
              <div class="muted" style="font-size:12px;margin-bottom:8px">
                Отметь, что есть. Если ничего нет — оставь пустым.
              </div>
              ${g.items.map(it => {
                const checked = set.has(it.item_id) ? "checked" : "";
                return `
                  <label class="opt">
                    <input type="checkbox" data-group="${escapeHtml(g.groupKey)}" data-item="${escapeHtml(it.item_id)}" ${checked}/>
                    <div style="flex:1">
                      <div>${escapeHtml(it.text || it.item_id)}</div>
                    </div>
                  </label>
                `;
              }).join("")}
            </div>
          `;
        }

        if (!html) {
          html = `<div class="card muted">В этом разделе пока нет вопросов.</div>`;
        }
        return html;
      }

      // Render shell
      render(`
        <div class="topbar">
          <div>
            <h1 style="margin:0">Проверка</h1>
            <div class="muted">
              <span class="pill">${escapeHtml(norm(branch?.city || STATE.city))}</span>
              <span class="pill">${escapeHtml(norm(branch?.branch_name || STATE.branchId))}</span>
            </div>
          </div>
        </div>

        ${renderTabs()}

        <div id="content">${renderActiveSectionContent()}</div>

        <div class="card">
          <button id="finish" disabled>Завершить</button>
          <button id="back" class="btnSecondary" style="margin-top:8px">К выбору филиала</button>
          <div class="muted" style="margin-top:10px;font-size:12px">Автосейв ✅</div>
        </div>
      `);

      const contentEl = document.getElementById("content");
      const finishBtn = document.getElementById("finish");

      function updateProgressAndFinishState() {
        const v = validateAll(singlesBySec, checkboxGroupsBySec, STATE.enabledSections);
        finishBtn.disabled = !v.ok;
      }

      function clearErrors() {
        document.querySelectorAll(".card.question").forEach(el => el.classList.remove("error"));
      }

      function paintErrors(v) {
        // singles
        for (const key of v.missingSingles) {
          const el = document.querySelector(`[data-single-key="${CSS.escape(key)}"]`);
          if (el) el.classList.add("error");
        }
      }

      function bindHandlers() {
        // tab switching
        document.querySelectorAll(".tab").forEach(el => {
          el.addEventListener("click", () => {
            const sec = el.getAttribute("data-sec");
            if (!sec) return;
            STATE.activeSection = sec;
            saveDraft();

            document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
            el.classList.add("active");

            contentEl.innerHTML = renderActiveSectionContent();
            bindHandlers(); // rebind for new content
            updateProgressAndFinishState();
          });
        });

        // single radios
        document.querySelectorAll('input[type="radio"]').forEach(inp => {
          inp.addEventListener("change", () => {
            const name = inp.name; // s_<key>
            const key = name.replace(/^s_/, "");
            STATE.singleAnswers[key] = inp.value;
            saveDraft();
            updateProgressAndFinishState();
          });
        });

        // checkbox items
        document.querySelectorAll('input[type="checkbox"][data-group]').forEach(inp => {
          inp.addEventListener("change", () => {
            const gk = inp.getAttribute("data-group");
            const item = inp.getAttribute("data-item");

            STATE.checkboxAnswers[gk] ??= new Set();

            if (inp.checked) STATE.checkboxAnswers[gk].add(item);
            else STATE.checkboxAnswers[gk].delete(item);

            saveDraft();
            updateProgressAndFinishState();
          });
        });
      }

      bindHandlers();
      updateProgressAndFinishState();

      document.getElementById("back").onclick = () => renderStart();

      finishBtn.onclick = () => {
        clearErrors();
        const v = validateAll(singlesBySec, checkboxGroupsBySec, STATE.enabledSections);
        if (!v.ok) {
          paintErrors(v);
          alert("Не заполнены ответы в разделах: " + v.missingSectionTitles.join(", "));
          updateProgressAndFinishState();
          return;
        }
        const result = computeResult(rows, singlesBySec, checkboxGroupsBySec, STATE.enabledSections);
        renderResultScreen(result, branch);
      };
    }

    // ====== BOOT ======
    (async function boot() {
      try {
        // Telegram ready
        if (window.Telegram && Telegram.WebApp) Telegram.WebApp.ready();

        appEl.textContent = "Загружаю данные…";
        const res = await fetch(DATA_URL);
        if (!res.ok) throw new Error("HTTP " + res.status);
        DATA = await res.json();

        renderStart();
      } catch (e) {
        renderError("Не получилось загрузить данные из таблицы", e);
      }
    })();
  </script>
</body>
</html>
