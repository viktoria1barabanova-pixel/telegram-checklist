<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Checklist</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root { --pad: 14px; --danger:#ff4d4f; --dangerBg:#fff1f0; }
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; margin: 0; padding: var(--pad); background:#fff; }
    h1 { font-size: 20px; margin: 0 0 10px; }
    h2 { font-size: 16px; margin: 16px 0 10px; }
    .muted { color: #666; }
    .card { border: 1px solid #e7e7e7; border-radius: 14px; padding: 12px; margin: 10px 0; background: #fff; }
    .card.error { border: 2px solid var(--danger); background: var(--dangerBg); }
    .row { display: grid; gap: 10px; }
    label { font-size: 12px; color: #666; }
    select, button { width: 100%; padding: 12px; border-radius: 12px; border: 1px solid #ddd; font-size: 16px; background: #fff; }
    button { border: none; background: #111; color: #fff; cursor: pointer; }
    button:disabled { background: #bbb; cursor: not-allowed; }
    .btnSecondary { background:#fff; color:#111; border:1px solid #ddd; }
    .tabs { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 6px; margin: 10px 0; }
    .tab { padding: 10px 12px; border-radius: 999px; border: 1px solid #ddd; background: #fff; white-space: nowrap; cursor: pointer; }
    .tab.active { background: #111; color: #fff; border-color: #111; }
    .pill { display:inline-block; padding: 6px 10px; border-radius: 999px; background:#f2f2f2; font-size: 12px; }
    .zoneBanner { width: 100%; padding: 14px 12px; border-radius: 14px; font-weight: 900; text-align: center; color: #111; }
    .zoneBanner.red { background: linear-gradient(135deg, #3a3a3a 0%, #b23a3a 55%, #d85a5a 100%); color: #fff; }
    .zoneBanner.yellow { background: linear-gradient(135deg, #2e7d32 0%, #c2a33a 55%, #d28a2f 100%); color: #111; }
    .zoneBanner.green { background: linear-gradient(135deg, #0b6b52 0%, #18a06f 55%, #56c271 100%); color: #fff; }
    .zoneBanner.gray { background: linear-gradient(135deg, #2f2f2f 0%, #6a6a6a 55%, #a0a0a0 100%); color: #fff; }
    .resultPercent { margin-top: 10px; font-size: 28px; font-weight: 900; }
    .hr { height: 1px; background: #eee; margin: 12px 0; }

    .q-title { font-weight: 800; margin-bottom: 6px; }
    .q-desc { font-size: 13px; color: #666; margin-bottom: 10px; }
.descRow { display:flex; align-items:flex-start; justify-content:space-between; gap:10px; }
.photoToggle { width:auto; min-width:36px; padding:6px 10px; border-radius:10px; border:1px solid #ddd; background:#fff; color:#111; font-weight:900; cursor:pointer; }
.photoWrap { margin-top:10px; display:none; }
.photoWrap.open { display:block; }
.photoWrap img { width:100%; border-radius:12px; display:block; }
    .opt { display:flex; align-items:flex-start; gap:10px; padding: 10px; border-radius: 12px; border: 1px solid #eee; margin-top: 8px; }
    .opt input { margin-top: 3px; }
    .groupTitle { font-weight: 900; margin: 14px 0 8px; }

    .topbar { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .progress { font-size: 12px; color:#666; }
    .warn { color: var(--danger); font-weight: 700; }
  </style>
</head>
<body>
  <div id="app" class="muted"></div>

  <script>
    // ====== 1) ПОДСТАВЬ СВОЙ URL (googleusercontent) ======
    const DATA_URL = "https://script.google.com/macros/s/AKfycbx-yZVSUsNaNKqNv_bJ8IFHgJ49vgJ3hK4qT4OI7nDKkyjXun1R1npEwxHbbs5M0UawSQ/exec";

    // ====== ZONE THRESHOLDS (percent) ======
    const ZONE_RED_MAX = 70;    // 0..70 => red
    const ZONE_YELLOW_MAX = 85; // 70..85 => yellow

    // ====== UTILS ======
    const appEl = document.getElementById("app");
    const norm = (v) => (v ?? "").toString().trim();
    const toBool = (v) => v === true || v === "TRUE" || v === "true" || v === 1 || v === "1";
    const escapeHtml = (s) => String(s).replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
    const uniq = (arr) => [...new Set(arr)];

    const IS_TG = !!(window.Telegram && Telegram.WebApp);
    const getTgName = () => {
      try {
        const u = Telegram.WebApp?.initDataUnsafe?.user;
        if (!u) return "";
        return norm([u.last_name, u.first_name].filter(Boolean).join(" ")) || norm(u.username) || "";
      } catch { return ""; }
    };
const driveToDirect = (url) => {
  const u = norm(url);
  if (!u) return "";

  // Already direct or normal URL
  if (!/^https?:\/\//i.test(u)) return "";

  // Google Drive patterns
  // 1) https://drive.google.com/file/d/FILE_ID/view?... 
  // 2) https://drive.google.com/open?id=FILE_ID
  // 3) https://drive.google.com/uc?id=FILE_ID&export=download
  let id = "";

  const m1 = u.match(/drive\.google\.com\/file\/d\/([a-zA-Z0-9_-]+)/);
  if (m1 && m1[1]) id = m1[1];

  if (!id) {
    const m2 = u.match(/[?&]id=([a-zA-Z0-9_-]+)/);
    if (m2 && m2[1]) id = m2[1];
  }

  if (id) {
    // Use googleusercontent image host. This is the most reliable for <img src> in browsers.
    // Note: Drive file must be shared as “Anyone with the link”.
    return `https://lh3.googleusercontent.com/d/${id}=w1200`;
  }

  // Not a Drive share link we recognize; return as-is
  return u;
};

const normPhoto = (r) => {
  const raw = norm(r.photo || r.photo_url || r.image || r.image_url);
  if (!raw) return "";
  return driveToDirect(raw);
};

    function render(html) { appEl.innerHTML = html; }

    function renderError(title, err) {
      render(`
        <h1>${escapeHtml(title)}</h1>
        <div class="card">
          <div class="muted">Скинь мне этот текст — быстро разрулю.</div>
          <div class="hr"></div>
          <pre style="white-space:pre-wrap">${escapeHtml(String(err?.stack || err))}</pre>
        </div>
      `);
    }

    // ====== STATE ======
let DATA = null;

const STATE = {
  city: "",
  fio: "", // required outside Telegram
  branchId: "",
  enabledSections: [],
  activeSection: "",
  // answers
  singleAnswers: {},   // key: section_code|question_id -> "ideal" | "acceptable" | "bad"
  checkboxAnswers: {}, // key: groupKey -> Set(itemId)
  isFinished: false,
  lastResult: null, // сюда сохраним итог, чтобы показывать его и блокировать редактирование
  issueNotes: {}, // key -> { text: string, photo: string(dataURL) }
  noteOpen: {},   // key -> boolean (toggle for checkbox issue note UI)
};

    function draftKey() { return `draft_v2_${STATE.branchId || "no_branch"}`; }

    const DRAFT_TTL_MS = 5 * 60 * 60 * 1000; // 5 hours

    function saveDraft() {
      try {
        const serialCheckbox = {};
        for (const [k, set] of Object.entries(STATE.checkboxAnswers)) serialCheckbox[k] = [...set];
        localStorage.setItem(draftKey(), JSON.stringify({
          city: STATE.city,
          fio: STATE.fio,
          branchId: STATE.branchId,
          enabledSections: STATE.enabledSections,
          activeSection: STATE.activeSection,
          singleAnswers: STATE.singleAnswers,
          checkboxAnswers: serialCheckbox,
          savedAt: Date.now(),
          isFinished: STATE.isFinished,
          lastResult: STATE.lastResult,
          issueNotes: STATE.issueNotes,
          noteOpen: STATE.noteOpen
        }));
      } catch {}
    }

    function loadDraft(branchId) {
      try {
        const raw = localStorage.getItem(`draft_v2_${branchId}`);
        if (!raw) return null;
        const d = JSON.parse(raw);
        const savedAt = Number(d.savedAt || 0);
        if (!savedAt || (Date.now() - savedAt) > DRAFT_TTL_MS) {
          // Draft is expired (or invalid) — remove and ignore
          localStorage.removeItem(`draft_v2_${branchId}`);
          return null;
        }
        // restore Sets
        const restored = {};
        for (const [k, arr] of Object.entries(d.checkboxAnswers || {})) restored[k] = new Set(arr);
        d.checkboxAnswers = restored;
        return d;
      } catch { return null; }
    }

function clearDraftForBranch(branchId) {
  try {
    if (!branchId) return;
    localStorage.removeItem(`draft_v2_${branchId}`);
  } catch {}

  STATE.singleAnswers = {};
  STATE.checkboxAnswers = {};
  STATE.activeSection = "";
  STATE.isFinished = false;
  STATE.lastResult = null;
  STATE.fio = "";
  STATE.issueNotes = {};
  STATE.noteOpen = {};
}

    // ====== DATA ADAPTER (твой формат таблицы) ======
    // ожидаем DATA.checklist строки с колонками:
    // section_code, question_id, question_text, question_description, question_type,
    // ideal_answer, acceptable_answer, bad_answer, score, severity, exclude_from_max, active, sort_order

    function getActiveSections() {
      return (DATA.sections || [])
        .filter(s => toBool(s.active) && norm(s.section_code))
        .sort((a,b) => Number(a.sort_order||0) - Number(b.sort_order||0));
    }

    function sectionsByCode() {
      const m = new Map();
      for (const s of getActiveSections()) m.set(norm(s.section_code), s);
      return m;
    }

    function getActiveBranches() {
      return (DATA.branches || [])
        .filter(b => toBool(b.active) && norm(b.city) && norm(b.branch_id) && norm(b.branch_name));
    }

    function getChecklistRows() {
      return (DATA.checklist || [])
        .filter(r => toBool(r.active) && norm(r.section_code) && norm(r.question_id) && norm(r.question_type));
    }

    function enabledSectionsFromBranch(branch) {
      const raw = norm(branch.enabled_sections_default);
      if (!raw) return [];
      return raw.split(",").map(s => s.trim()).filter(Boolean);
    }

    // SINGLE questions: group by section_code + question_id
    function buildSingles(rows, enabledSections) {
      const m = {}; // sec -> [{...}]
      for (const r of rows) {
        const type = norm(r.question_type).toLowerCase();
        if (type !== "single" && type !== "radio") continue;
        const sec = norm(r.section_code);
        if (!enabledSections.includes(sec)) continue;

        const key = `${sec}|${norm(r.question_id)}`;
        m[sec] ??= [];
        // one row per single question (в твоей таблице это 1 строка)
        m[sec].push({
          key,
          section_code: sec,
          question_id: norm(r.question_id),
          question_text: norm(r.question_text),
          question_description: norm(r.question_description),
photo: normPhoto(r),
          ideal_answer: norm(r.ideal_answer),
          acceptable_answer: norm(r.acceptable_answer),
          bad_answer: norm(r.bad_answer),
          score: Number(r.score || 0),
          severity: norm(r.severity),
          exclude_from_max: toBool(r.exclude_from_max),
          sort_order: Number(r.sort_order || 0)
        });
      }
      for (const sec of Object.keys(m)) {
        m[sec].sort((a,b)=>a.sort_order-b.sort_order || a.question_id.localeCompare(b.question_id));
      }
      return m;
    }

// CHECKBOX items: each row is a separate yes/no checkbox (no grouping)
function buildCheckboxGroups(rows, enabledSections) {
  const m = {}; // sec -> [item]

  for (const r of rows) {
    const type = norm(r.question_type).toLowerCase();
    if (type !== "checkbox") continue;

    const sec = norm(r.section_code);
    if (!enabledSections.includes(sec)) continue;

    const key = `${sec}|${norm(r.question_id)}`;
    m[sec] ??= [];
    m[sec].push({
      key,
      section_code: sec,
      question_id: norm(r.question_id),
      title: norm(r.question_text) || norm(r.question_id),
      description: norm(r.question_description),
      photo: normPhoto(r),
      score: Number(r.score || 0),
      severity: norm(r.severity),
      exclude_from_max: toBool(r.exclude_from_max),
      sort_order: Number(r.sort_order || 0)
    });
  }

  for (const sec of Object.keys(m)) {
    m[sec].sort((a,b)=>a.sort_order-b.sort_order || a.question_id.localeCompare(b.question_id));
  }

  return m;
}

    // ====== SORT SECTION CODES BY ORDER ======

    function sortSectionCodesByOrder(codes) {
      const map = sectionsByCode();
      return (codes || [])
        .map(c => norm(c))
        .filter(Boolean)
        .filter(c => map.has(c))
        .sort((a, b) => {
          const sa = map.get(a);
          const sb = map.get(b);
          return Number(sa?.sort_order || 0) - Number(sb?.sort_order || 0);
        });
    }

    // ====== VALIDATION ======
    function validateAll(singlesBySec, checkboxGroupsBySec, enabledSections) {
      const sectionMap = sectionsByCode();

      const missingSingles = new Set();     // keys of single questions
      const missingSections = new Set();

      // singles
      for (const sec of enabledSections) {
        for (const q of (singlesBySec[sec] || [])) {
          if (!STATE.singleAnswers[q.key]) {
            missingSingles.add(q.key);
            missingSections.add(sec);
          }
        }
      }

      const missingSectionTitles = [...missingSections].map(code => {
        const s = sectionMap.get(code);
        return s ? norm(s.title) : code;
      });

      return {
        ok: missingSingles.size === 0,
        missingSingles,
        missingSections,
        missingSectionTitles
      };
    }

    // ====== RESULTS (итог / зона / ошибки) ======
    function computeResult(rows, singlesBySec, checkboxGroupsBySec, enabledSections) {
      let earned = 0;
      let maxScore = 0;

      const issuesBySection = {}; // sec -> array of strings
      const addIssue = (sec, text) => {
        issuesBySection[sec] ??= [];
        issuesBySection[sec].push(text);
      };

      // SINGLE scoring
      for (const sec of enabledSections) {
        for (const q of (singlesBySec[sec] || [])) {
          if (!q.exclude_from_max) maxScore += Number(q.score || 0);

          const sel = STATE.singleAnswers[q.key];
          if (!sel) continue;

          if (sel === "ideal") {
            earned += Number(q.score || 0);
          } else if (sel === "acceptable") {
            earned += Number(q.score || 0) / 2;
            addIssue(sec, `${q.question_text}: ${q.acceptable_answer}`);
          } else if (sel === "bad") {
            addIssue(sec, `${q.question_text}: ${q.bad_answer}`);
          }
        }
      }

      // CHECKBOX scoring (each checkbox row is a yes/no item)
      const checkedSet = STATE.checkboxAnswers["_items"] || new Set();
      for (const sec of enabledSections) {
        for (const it of (checkboxGroupsBySec[sec] || [])) {
          if (!it.exclude_from_max) maxScore += Number(it.score || 0);

          if (checkedSet.has(it.key)) {
            earned += Number(it.score || 0);
          } else {
            addIssue(sec, `${it.title}`);
          }
        }
      }

      const percent = maxScore > 0 ? Math.round((earned / maxScore) * 1000) / 10 : 0;
      let zone = "green";
      if (maxScore <= 0) zone = "gray";
      else if (percent <= ZONE_RED_MAX) zone = "red";
      else if (percent <= ZONE_YELLOW_MAX) zone = "yellow";

      return { earned, maxScore, percent, zone, issuesBySection };
    }

    function zoneLabel(zone) {
      if (zone === "gray") return "СЕРАЯ ЗОНА";
      if (zone === "red") return "КРАСНАЯ ЗОНА";
      if (zone === "yellow") return "ЖЁЛТАЯ ЗОНА";
      return "ЗЕЛЁНАЯ ЗОНА";
    }

    function renderResultScreen(result, branch) {
      const sectionMap = sectionsByCode();
      const secTitle = (code) => {
        const s = sectionMap.get(code);
        return s ? norm(s.title) : code;
      };

      const issuesSections = Object.keys(result.issuesBySection || {});

      render(`
        <h1>Итог</h1>
        <div class="muted">
          ${STATE.fio ? `<span class="pill">${escapeHtml(norm(STATE.fio))}</span>` : ""}
          <span class="pill">${escapeHtml(norm(branch?.city || STATE.city))}</span>
          <span class="pill">${escapeHtml(norm(branch?.branch_name || STATE.branchId))}</span>
        </div>

        <div class="card" style="border:none;padding:0">
          <div class="zoneBanner ${escapeHtml(result.zone)}">${escapeHtml(zoneLabel(result.zone))}</div>
          <div class="resultPercent">${escapeHtml(result.percent)}%</div>
        </div>

        <div class="card">
          <h2 style="margin-top:0">Где есть ошибки</h2>
          ${issuesSections.length ? issuesSections.map(sec => `
            <div style="margin-top:12px">
              <div style="font-weight:900">${escapeHtml(secTitle(sec))}</div>
              <div class="muted" style="font-size:12px;margin-top:6px">
                ${(result.issuesBySection[sec] || []).map(x => `• ${escapeHtml(x)}`).join('<br/>')}
              </div>
            </div>
          `).join('') : `<div class="muted">Ошибок нет ✅</div>`}
        </div>

        <div class="card">
	  <button id="resetDraftResult" class="btnSecondary">Сбросить черновик этого филиала</button>
	  <button id="backToStart" class="btnSecondary" style="margin-top:8px">Новая проверка</button>
	</div>
      `);

document.getElementById("resetDraftResult").onclick = () => {
  clearDraftForBranch(STATE.branchId);
  renderStart();
};
document.getElementById("backToStart").onclick = () => renderStart();
    }

    // ====== UI: START ======
    function renderStart(isLoading = false) {
      const branches = DATA ? getActiveBranches() : [];
      const cities = uniq(branches.map(b => norm(b.city))).sort();

      if (IS_TG && !STATE.fio) STATE.fio = getTgName();

      render(`
        <h1>Проверка филиала</h1>
        <div class="card">
          <div class="row">
            ${!IS_TG ? `
            <div>
              <label>ФИО</label>
              <input id="fio" placeholder="Иванов Иван Иванович" style="width:100%;padding:12px;border-radius:12px;border:1px solid #ddd;font-size:16px" />
            </div>
            ` : ""}
            <div>
              <label>Город</label>
              <select id="city">
                <option value="">${isLoading ? "Загружаю список…" : "Выбери город"}</option>
                ${cities.map(c => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join("")}
              </select>
            </div>

            <div>
              <label>Филиал</label>
              <select id="branch" ${isLoading ? "disabled" : "disabled"}>
                <option value="">Сначала выбери город</option>
              </select>
            </div>

            <button id="go" disabled>${isLoading ? "Загружаю…" : "Начать"}</button>
          </div>
        </div>
        <div class="muted">${isLoading ? "Подгружаю вопросы и список филиалов…" : "Все вопросы обязательные ✅"}</div>
      `);

      const citySel = document.getElementById("city");
      const branchSel = document.getElementById("branch");
      const goBtn = document.getElementById("go");
      const fioInp = document.getElementById("fio");
      if (fioInp) {
        fioInp.value = STATE.fio || "";
        fioInp.addEventListener("input", () => {
          STATE.fio = fioInp.value;
          saveDraft();
          goBtn.disabled = !branchSel.value || !norm(STATE.fio);
        });
      }

      if (isLoading) return;

      citySel.addEventListener("change", () => {
        const city = citySel.value;
        const list = branches.filter(b => norm(b.city) === norm(city));
        branchSel.innerHTML = `<option value="">Выбери филиал</option>` + list
          .map(b => `<option value="${escapeHtml(norm(b.branch_id))}">${escapeHtml(norm(b.branch_name))}</option>`)
          .join("");
        branchSel.disabled = false;
        goBtn.disabled = true;
      });

      branchSel.addEventListener("change", () => {
        goBtn.disabled = !branchSel.value || (!IS_TG && !norm(STATE.fio));
      });

      goBtn.addEventListener("click", () => {
        if (!IS_TG && !norm(STATE.fio)) {
          alert("Вне Telegram нужно указать ФИО");
          return;
        }
        STATE.city = citySel.value;
        STATE.branchId = branchSel.value;

        const branch = getActiveBranches().find(b => norm(b.branch_id) === norm(STATE.branchId));
        const defaultsRaw = branch ? enabledSectionsFromBranch(branch) : [];
        const allSections = getActiveSections().map(s => norm(s.section_code));
        const chosen = defaultsRaw.length ? defaultsRaw : allSections;
        // IMPORTANT: tabs order must follow Sections.sort_order
        STATE.enabledSections = sortSectionCodesByOrder(chosen);

        // load draft if exists
        const d = loadDraft(STATE.branchId);
        if (d) {
          STATE.enabledSections = sortSectionCodesByOrder(d.enabledSections?.length ? d.enabledSections : STATE.enabledSections);
          STATE.activeSection = d.activeSection || "";
          STATE.singleAnswers = d.singleAnswers || {};
          STATE.checkboxAnswers = d.checkboxAnswers || {};
          STATE.isFinished = !!d.isFinished;
          STATE.lastResult = d.lastResult || null;
          STATE.fio = d.fio || STATE.fio;
          STATE.issueNotes = d.issueNotes || {};
          STATE.noteOpen = d.noteOpen || {};
        }

        // set active section
        if (!STATE.activeSection || !STATE.enabledSections.includes(STATE.activeSection)) {
          STATE.activeSection = STATE.enabledSections[0];
        }

        saveDraft();
        if (STATE.isFinished && STATE.lastResult) {
          renderResultScreen(STATE.lastResult, branch);
          return;
        }
        renderSurvey();
      });
    }

    // ====== UI: SURVEY ======
    function renderSurvey() {
if (STATE.isFinished && STATE.lastResult) {
  const branch = getActiveBranches().find(b => norm(b.branch_id) === norm(STATE.branchId));
  renderResultScreen(STATE.lastResult, branch);
  return;
}
      const branch = getActiveBranches().find(b => norm(b.branch_id) === norm(STATE.branchId));
      const sectionMap = sectionsByCode();

      const rows = getChecklistRows();
      const singlesBySec = buildSingles(rows, STATE.enabledSections);
      const checkboxGroupsBySec = buildCheckboxGroups(rows, STATE.enabledSections);

      function sectionTitle(code) {
        const s = sectionMap.get(code);
        return s ? norm(s.title) : code;
      }

      function renderTabs() {
        return `
          <div class="tabs">
            ${STATE.enabledSections.map(code => {
              const active = code === STATE.activeSection ? "active" : "";
              return `<div class="tab ${active}" data-sec="${escapeHtml(code)}">${escapeHtml(sectionTitle(code))}</div>`;
            }).join("")}
          </div>
        `;
      }

      function renderActiveSectionContent() {
        const sec = STATE.activeSection;
        const singles = singlesBySec[sec] || [];
        const groups = checkboxGroupsBySec[sec] || [];

        let html = "";

        // SINGLE QUESTIONS
        for (const q of singles) {
          const selected = STATE.singleAnswers[q.key] || "";
          html += `
            <div class="card question" data-single-key="${escapeHtml(q.key)}">
              <div class="q-title">${escapeHtml(q.question_text || q.question_id)}</div>
              ${(q.question_description || q.photo) ? `
  <div class="q-desc">
    <div class="descRow">
      <div>${q.question_description ? escapeHtml(q.question_description) : ""}</div>
      ${q.photo ? `<button type="button" class="photoToggle" data-photo-toggle="${escapeHtml(q.key)}">+</button>` : ""}
    </div>
    ${q.photo ? `<div class="photoWrap" data-photo-wrap="${escapeHtml(q.key)}"><img src="${escapeHtml(q.photo)}" alt="" loading="lazy" referrerpolicy="no-referrer"/></div>` : ""}
  </div>
` : ""}
              ${(() => {
                const opts = [
                  { value: "ideal", text: norm(q.ideal_answer) },
                  { value: "acceptable", text: norm(q.acceptable_answer) },
                  { value: "bad", text: norm(q.bad_answer) }
                ].filter(o => o.text);

                // If the previously selected value no longer exists (e.g., acceptable removed), clear it
                const allowed = new Set(opts.map(o => o.value));
                if (selected && !allowed.has(selected)) {
                  delete STATE.singleAnswers[q.key];
                  saveDraft();
                }

                const selectedNow = STATE.singleAnswers[q.key] || "";

                return opts.map(opt => `
                  <label class="opt">
                    <input type="radio" name="s_${escapeHtml(q.key)}" value="${escapeHtml(opt.value)}" ${selectedNow===opt.value?"checked":""}/>
                    <div style="flex:1">
                      <div>${escapeHtml(opt.text)}</div>
                    </div>
                  </label>
                `).join("");
              })()}
              ${(() => {
                const selNow = STATE.singleAnswers[q.key] || "";
                const nonIdeal = selNow && selNow !== "ideal";
                return nonIdeal ? noteBlockHtml(q.key, true) : "";
              })()}
            </div>
          `;
        }

// CHECKBOX ITEMS (each row = one yes/no item)
const checkedSet = STATE.checkboxAnswers["_items"] || new Set();
for (const it of groups) {
  const checked = checkedSet.has(it.key) ? "checked" : "";

  html += `
    <div class="card question" data-checkbox-key="${escapeHtml(it.key)}">
      <div class="q-title">${escapeHtml(it.title)}</div>

      ${(it.description || it.photo) ? `
        <div class="q-desc">
          <div class="descRow">
            <div>${it.description ? escapeHtml(it.description) : ""}</div>
            ${it.photo ? `<button type="button" class="photoToggle" data-photo-toggle="${escapeHtml(it.key)}">+</button>` : ""}
          </div>
          ${it.photo ? `<div class="photoWrap" data-photo-wrap="${escapeHtml(it.key)}"><img src="${escapeHtml(it.photo)}" alt="" loading="lazy" referrerpolicy="no-referrer"/></div>` : ""}
        </div>
      ` : ""}

      <label class="opt">
        <input type="checkbox" data-checkbox-key="${escapeHtml(it.key)}" ${checked}/>
        <div style="flex:1"><div>Есть</div></div>
      </label>
      ${(() => {
        const isOk = checkedSet.has(it.key);
        if (isOk) return "";
        const open = !!STATE.noteOpen[it.key] || !!(STATE.issueNotes[it.key]?.text) || !!(STATE.issueNotes[it.key]?.photo);
        return `
          <button type="button" class="btnSecondary" data-note-toggle="${escapeHtml(it.key)}" style="margin-top:10px">Комментарий/фото</button>
          ${noteBlockHtml(it.key, open)}
        `;
      })()}
    </div>
  `;
}

        if (!html) {
          html = `<div class="card muted">В этом разделе пока нет вопросов.</div>`;
        }
        return html;
      }

      // Render shell
      render(`
        <div class="topbar">
          <div>
            <h1 style="margin:0">Проверка</h1>
            <div class="muted">
              ${STATE.fio ? `<span class="pill">${escapeHtml(norm(STATE.fio))}</span>` : ""}
              <span class="pill">${escapeHtml(norm(branch?.city || STATE.city))}</span>
              <span class="pill">${escapeHtml(norm(branch?.branch_name || STATE.branchId))}</span>
            </div>
          </div>
        </div>

        ${renderTabs()}

        <div id="content">${renderActiveSectionContent()}</div>

<div class="card">
  <button id="finish" disabled>Завершить</button>
  <button id="resetDraft" class="btnSecondary" style="margin-top:8px">Сбросить черновик этого филиала</button>
  <button id="back" class="btnSecondary" style="margin-top:8px">К выбору филиала</button>
  <div class="muted" style="margin-top:10px;font-size:12px">Автосейв ✅ (черновик хранится 5 часов)</div>
</div>
      `);

      const contentEl = document.getElementById("content");
      const finishBtn = document.getElementById("finish");

      function updateProgressAndFinishState() {
        const v = validateAll(singlesBySec, checkboxGroupsBySec, STATE.enabledSections);
        finishBtn.disabled = !v.ok;
      }

      function clearErrors() {
        document.querySelectorAll(".card.question").forEach(el => el.classList.remove("error"));
      }

      function paintErrors(v) {
        // singles
        for (const key of v.missingSingles) {
          const el = document.querySelector(`[data-single-key="${CSS.escape(key)}"]`);
          if (el) el.classList.add("error");
        }
      }

      function ensureNote(key) {
        STATE.issueNotes[key] ??= { text: "", photo: "" };
        return STATE.issueNotes[key];
      }

      function noteBlockHtml(key, show) {
        const n = ensureNote(key);
        const hidden = show ? "" : "display:none";
        const hasPhoto = !!n.photo;

        return `
        <div class="noteBlock" data-note-block="${escapeHtml(key)}" style="margin-top:10px;${hidden}">
          <label>Комментарий</label>
          <textarea data-note-text="${escapeHtml(key)}" placeholder="Комментарий" style="width:100%;min-height:74px;padding:12px;border-radius:12px;border:1px solid #ddd;font-size:14px;resize:vertical">${escapeHtml(n.text || "")}</textarea>

          <div style="margin-top:10px">
            <label>Фото</label>
            <input type="file" accept="image/*" data-note-file="${escapeHtml(key)}" style="width:100%" />
          </div>

          ${hasPhoto ? `
            <div style="margin-top:10px">
              <img src="${escapeHtml(n.photo)}" alt="" style="width:100%;border-radius:12px;display:block"/>
              <button type="button" class="btnSecondary" data-note-remove="${escapeHtml(key)}" style="margin-top:8px">Удалить фото</button>
            </div>
          ` : ""}
        </div>
      `;
      }

      function readImageAsDataURL(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(String(reader.result || ""));
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      function bindHandlers() {
        // tab switching
        document.querySelectorAll(".tab").forEach(el => {
          el.addEventListener("click", () => {
            const sec = el.getAttribute("data-sec");
            if (!sec) return;
            STATE.activeSection = sec;
            saveDraft();

            document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
            el.classList.add("active");

            contentEl.innerHTML = renderActiveSectionContent();
            bindHandlers(); // rebind for new content
            updateProgressAndFinishState();
          });
        });

        // single radios
        document.querySelectorAll('input[type="radio"]').forEach(inp => {
          inp.addEventListener("change", () => {
            const name = inp.name; // s_<key>
            const key = name.replace(/^s_/, "");
            STATE.singleAnswers[key] = inp.value;
            saveDraft();
            // re-render current section so note block appears/disappears immediately
            contentEl.innerHTML = renderActiveSectionContent();
            bindHandlers();
            updateProgressAndFinishState();
          });
        });

        // checkbox items
// checkbox items (per-row yes/no)
document.querySelectorAll('input[type="checkbox"][data-checkbox-key]').forEach(inp => {
  inp.addEventListener("change", () => {
    const key = inp.getAttribute("data-checkbox-key");
    STATE.checkboxAnswers["_items"] ??= new Set();

    if (inp.checked) STATE.checkboxAnswers["_items"].add(key);
    else STATE.checkboxAnswers["_items"].delete(key);

    saveDraft();
    contentEl.innerHTML = renderActiveSectionContent();
    bindHandlers();
    updateProgressAndFinishState();
  });
});

// photo toggle (+) for both single + checkbox cards
// When opening, smoothly scroll the image into the center of the screen
function centerIntoView(el) {
  try {
    el.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
  } catch {
    const rect = el.getBoundingClientRect();
    const y = (window.pageYOffset || document.documentElement.scrollTop || 0) + rect.top - (window.innerHeight / 2) + (rect.height / 2);
    window.scrollTo({ top: Math.max(0, y), behavior: 'smooth' });
  }
}

document.querySelectorAll('[data-photo-toggle]').forEach(btn => {
  btn.addEventListener('click', () => {
    const k = btn.getAttribute('data-photo-toggle');
    const wrap = document.querySelector(`[data-photo-wrap="${CSS.escape(k)}"]`);
    if (!wrap) return;

    const willOpen = !wrap.classList.contains('open');

    if (willOpen) {
      wrap.classList.add('open');
      btn.textContent = '−';

      const img = wrap.querySelector('img');
      const target = img || wrap;

      const doCenter = () => {
        // wait for layout after display change
        requestAnimationFrame(() => {
          // small delay improves first-open centering on mobile/desktop
          setTimeout(() => centerIntoView(target), 40);
        });
      };

      // If image hasn't loaded yet, center after it loads
      if (img && !img.complete) {
        img.addEventListener('load', doCenter, { once: true });
        img.addEventListener('error', doCenter, { once: true });
      }

      // Also center immediately (covers cached images)
      doCenter();
    } else {
      wrap.classList.remove('open');
      btn.textContent = '+';
    }
  });
});

// image error handler (Drive permissions / broken links)
document.querySelectorAll('.photoWrap img').forEach(img => {
  img.addEventListener('error', () => {
    // prevent duplicate messages
    const wrap = img.closest('.photoWrap');
    if (!wrap) return;
    if (wrap.querySelector('[data-img-error]')) return;

    img.style.display = 'none';
    const msg = document.createElement('div');
    msg.setAttribute('data-img-error', '1');
    msg.className = 'muted';
    msg.style.fontSize = '12px';
    msg.style.marginTop = '8px';
    msg.textContent = 'Фото недоступно — проверь доступ по ссылке (Drive: «Все у кого есть ссылка»).';
    wrap.appendChild(msg);
  }, { once: true });
});

        // notes: toggle
        document.querySelectorAll('[data-note-toggle]').forEach(btn => {
          btn.addEventListener('click', () => {
            const key = btn.getAttribute('data-note-toggle');
            if (!key) return;
            STATE.noteOpen[key] = !STATE.noteOpen[key];
            saveDraft();
            contentEl.innerHTML = renderActiveSectionContent();
            bindHandlers();
          });
        });

        // notes: textarea
        document.querySelectorAll('textarea[data-note-text]').forEach(el => {
          el.addEventListener('input', () => {
            const key = el.getAttribute('data-note-text');
            if (!key) return;
            ensureNote(key).text = el.value;
            saveDraft();
          });
        });

        // notes: file upload
        document.querySelectorAll('input[type="file"][data-note-file]').forEach(inp => {
          inp.addEventListener('change', async () => {
            const key = inp.getAttribute('data-note-file');
            const file = inp.files && inp.files[0];
            if (!key || !file) return;

            if (file.size > 4 * 1024 * 1024) {
              alert('Фото слишком большое. Выбери файл до 4 МБ.');
              inp.value = '';
              return;
            }

            try {
              ensureNote(key).photo = await readImageAsDataURL(file);
              STATE.noteOpen[key] = true;
              saveDraft();
              contentEl.innerHTML = renderActiveSectionContent();
              bindHandlers();
            } catch (e) {
              alert('Не удалось прочитать фото');
            }
          });
        });

        // notes: remove photo
        document.querySelectorAll('[data-note-remove]').forEach(btn => {
          btn.addEventListener('click', () => {
            const key = btn.getAttribute('data-note-remove');
            if (!key) return;
            ensureNote(key).photo = '';
            saveDraft();
            contentEl.innerHTML = renderActiveSectionContent();
            bindHandlers();
          });
        });
      }

      bindHandlers();
      updateProgressAndFinishState();

      document.getElementById("back").onclick = () => renderStart();
document.getElementById("resetDraft").onclick = () => {
  clearDraftForBranch(STATE.branchId);
  renderStart();
};

      finishBtn.onclick = () => {
        clearErrors();
        const v = validateAll(singlesBySec, checkboxGroupsBySec, STATE.enabledSections);
        if (!v.ok) {
          paintErrors(v);
          alert("Не заполнены ответы в разделах: " + v.missingSectionTitles.join(", "));
          updateProgressAndFinishState();
          return;
        }
const result = computeResult(rows, singlesBySec, checkboxGroupsBySec, STATE.enabledSections);
STATE.isFinished = true;
STATE.lastResult = result;
saveDraft();
renderResultScreen(result, branch);
      };
    }

    // ====== BOOT ======
    (async function boot() {
      try {
        // Telegram ready
        if (window.Telegram && Telegram.WebApp) Telegram.WebApp.ready();

        // Show start UI immediately while data loads
        renderStart(true);

        const res = await fetch(DATA_URL);
        if (!res.ok) throw new Error("HTTP " + res.status);
        DATA = await res.json();

        renderStart(false);
      } catch (e) {
        renderError("Не получилось загрузить данные из таблицы", e);
      }
    })();
  </script>
</body>
</html>
