<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Checklist</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root { --pad: 14px; --danger:#ff4d4f; --dangerBg:#fff1f0; }
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; margin: 0; padding: var(--pad); background:#fff; }
    h1 { font-size: 20px; margin: 0 0 10px; }
    h2 { font-size: 16px; margin: 16px 0 10px; }
    .muted { color: #666; }
    .card { border: 1px solid #e7e7e7; border-radius: 14px; padding: 12px; margin: 10px 0; background: #fff; }
    .card.error { border: 2px solid var(--danger); background: var(--dangerBg); }
    .row { display: grid; gap: 10px; }
    label { font-size: 12px; color: #666; }
    select, button { width: 100%; padding: 12px; border-radius: 12px; border: 1px solid #ddd; font-size: 16px; background: #fff; }
    button { border: none; background: #111; color: #fff; cursor: pointer; }
    button:disabled { background: #bbb; cursor: not-allowed; }
    .btnSecondary { background:#fff; color:#111; border:1px solid #ddd; }
    .tabs {
      position: sticky;
      top: 0;
      z-index: 1000;
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding: 10px 0 6px;
      margin: 0 0 12px;
      background: #fff;
      box-shadow: 0 2px 6px rgba(0,0,0,0.06);
    }
    .tab { padding: 10px 12px; border-radius: 999px; border: 1px solid #ddd; background: #fff; white-space: nowrap; cursor: pointer; }
    .tab.active { background: #111; color: #fff; border-color: #111; }
    .pill { display:inline-block; padding: 6px 10px; border-radius: 999px; background:#f2f2f2; font-size: 12px; }
    .zoneBanner { width: 100%; padding: 14px 12px; border-radius: 14px; font-weight: 900; text-align: center; color: #111; }
    .zoneBanner.red { background: linear-gradient(135deg, #3a3a3a 0%, #b23a3a 55%, #d85a5a 100%); color: #fff; }
    .zoneBanner.yellow { background: linear-gradient(135deg, #2e7d32 0%, #c2a33a 55%, #d28a2f 100%); color: #111; }
    .zoneBanner.green { background: linear-gradient(135deg, #0b6b52 0%, #18a06f 55%, #56c271 100%); color: #fff; }
    .zoneBanner.gray { background: linear-gradient(135deg, #2f2f2f 0%, #6a6a6a 55%, #a0a0a0 100%); color: #fff; }
    .resultPercent { margin-top: 10px; font-size: 28px; font-weight: 900; }
    .hr { height: 1px; background: #eee; margin: 12px 0; }

    .q-title { font-weight: 800; margin-bottom: 6px; }
    .q-desc { font-size: 13px; color: #666; margin-bottom: 10px; }
    .q-desc a { color:#1a73e8; text-decoration: underline; }
    .q-desc a:visited { color:#1a73e8; }
    .q-desc a:hover { opacity:.85; }
    .descRow { display:flex; align-items:flex-start; justify-content:space-between; gap:10px; }
    .photoToggle { width:auto; min-width:36px; padding:6px 10px; border-radius:10px; border:1px solid #ddd; background:#fff; color:#111; font-weight:900; cursor:pointer; }
    .photoWrap { margin-top:10px; display:none; }
    .photoWrap.open { display:block; }
    .photoWrap img { width:100%; border-radius:12px; display:block; }

    .opt { display:flex; align-items:flex-start; gap:10px; padding: 10px; border-radius: 12px; border: 1px solid #eee; margin-top: 8px; }
    .opt input { margin-top: 3px; }
    .groupTitle { font-weight: 900; margin: 14px 0 8px; }

    .topbar { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .progress { font-size: 12px; color:#666; }
    .warn { color: var(--danger); font-weight: 700; }

    /* ===== thumbnails + modal for issue photos ===== */
    .thumbGrid { display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
    .thumb { width:74px; height:74px; border-radius:12px; object-fit:cover; border:1px solid #e7e7e7; cursor:pointer; background:#f5f5f5; }
    .thumbBtn { width:auto; padding:6px 10px; border-radius:10px; border:1px solid #ddd; background:#fff; color:#111; cursor:pointer; }

    .modalOverlay { position:fixed; inset:0; background:rgba(0,0,0,.72); display:none; align-items:center; justify-content:center; padding:18px; z-index:9999; }
    .modalOverlay.open { display:flex; }
    .modalBox { max-width:980px; width:100%; max-height:92vh; background:#111; border-radius:18px; overflow:hidden; border:1px solid rgba(255,255,255,.12); }
    .modalTop { display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px 12px; background:rgba(0,0,0,.35); color:#fff; }
    .modalTop .title { font-weight:800; font-size:14px; opacity:.9; }
    .modalTop .actions { display:flex; gap:8px; }
    .modalTop button { width:auto; padding:8px 10px; border-radius:12px; background:rgba(255,255,255,.1); color:#fff; border:1px solid rgba(255,255,255,.14); }
    .modalImgWrap { display:flex; align-items:center; justify-content:center; background:#111; }
    .modalImg { max-width:100%; max-height:82vh; display:block; }
  </style>
</head>
<body>
  <div id="app" class="muted"></div>

  <!-- Image modal -->
  <div id="imgModal" class="modalOverlay" role="dialog" aria-modal="true">
    <div class="modalBox">
      <div class="modalTop">
        <div class="title" id="imgModalTitle">Фото</div>
        <div class="actions">
          <button type="button" id="imgPrev">◀</button>
          <button type="button" id="imgNext">▶</button>
          <button type="button" id="imgClose">✕</button>
        </div>
      </div>
      <div class="modalImgWrap">
        <img id="imgModalEl" class="modalImg" alt="" />
      </div>
    </div>
  </div>

  <script>
    // ====== 1) ПОДСТАВЬ СВОЙ URL (googleusercontent) ======
    const DATA_URL = "https://script.google.com/macros/s/AKfycbx-yZVSUsNaNKqNv_bJ8IFHgJ49vgJ3hK4qT4OI7nDKkyjXun1R1npEwxHbbs5M0UawSQ/exec";

    // ====== ZONE THRESHOLDS (percent) ======
    const ZONE_RED_MAX = 70;    // 0..70 => red
    const ZONE_YELLOW_MAX = 85; // 70..85 => yellow

    // ====== UTILS ======
    const appEl = document.getElementById("app");
    const norm = (v) => (v ?? "").toString().trim();
    const toBool = (v) => v === true || v === "TRUE" || v === "true" || v === 1 || v === "1";
    const escapeHtml = (s) => String(s).replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
    const uniq = (arr) => [...new Set(arr)];

    // Convert plain text to HTML with safe clickable links.
    // Supports:
    //  - Markdown links: [text](https://example.com)
    //  - Bare URLs: https://example.com
    // Keeps all other text escaped.
    function richTextHtml(input) {
      const s0 = norm(input);
      if (!s0) return "";

      // Escape first (so user can't inject HTML), then re-introduce <a> tags safely.
      let s = escapeHtml(s0);

      // Convert new lines to <br>
      s = s.replace(/\r\n|\r|\n/g, "<br>");

      // Markdown: [text](url)
      // (Run before bare URL so it doesn't double-linkify)
      s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, (m, text, url) => {
        const safeText = escapeHtml(String(text));
        const safeUrl = escapeHtml(String(url));
        return `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer">${safeText}</a>`;
      });

      // Bare URLs (http/https)
      // Avoid linking inside existing anchors
      s = s.replace(/(^|[^">])(https?:\/\/[^\s<]+)/g, (m, prefix, url) => {
        const safeUrl = escapeHtml(String(url));
        return `${prefix}<a href="${safeUrl}" target="_blank" rel="noopener noreferrer">${safeUrl}</a>`;
      });

      return s;
    }

    const IS_TG = !!(window.Telegram && Telegram.WebApp);
    const getTgName = () => {
      try {
        const u = Telegram.WebApp?.initDataUnsafe?.user;
        if (!u) return "";
        return norm([u.last_name, u.first_name].filter(Boolean).join(" ")) || norm(u.username) || "";
      } catch { return ""; }
    };

    const driveToDirect = (url) => {
      const u = norm(url);
      if (!u) return "";
      if (!/^https?:\/\//i.test(u)) return "";

      let id = "";
      const m1 = u.match(/drive\.google\.com\/file\/d\/([a-zA-Z0-9_-]+)/);
      if (m1 && m1[1]) id = m1[1];

      if (!id) {
        const m2 = u.match(/[?&]id=([a-zA-Z0-9_-]+)/);
        if (m2 && m2[1]) id = m2[1];
      }

      if (id) return `https://lh3.googleusercontent.com/d/${id}=w1200`;
      return u;
    };

    const normPhoto = (r) => {
      const raw = norm(r.photo || r.photo_url || r.image || r.image_url);
      if (!raw) return "";
      return driveToDirect(raw);
    };

    function render(html) { appEl.innerHTML = html; }

    // ====== IMAGE MODAL (global, null-guards) ======
    const modalEl = document.getElementById('imgModal');
    const modalImg = document.getElementById('imgModalEl');
    const modalTitle = document.getElementById('imgModalTitle');
    const btnPrev = document.getElementById('imgPrev');
    const btnNext = document.getElementById('imgNext');
    const btnClose = document.getElementById('imgClose');

    let MODAL_IMAGES = [];
    let MODAL_INDEX = 0;

    function modalRender() {
      if (!modalImg || !modalTitle) return;
      const src = MODAL_IMAGES[MODAL_INDEX] || '';
      modalImg.src = src;
      modalTitle.textContent = `Фото ${MODAL_INDEX + 1}/${MODAL_IMAGES.length}`;
      if (btnPrev) btnPrev.disabled = MODAL_IMAGES.length <= 1;
      if (btnNext) btnNext.disabled = MODAL_IMAGES.length <= 1;
    }

    function openImageModal(images, index = 0) {
      if (!modalEl) return;
      MODAL_IMAGES = (images || []).filter(Boolean);
      MODAL_INDEX = Math.max(0, Math.min(index, MODAL_IMAGES.length - 1));
      if (!MODAL_IMAGES.length) return;
      modalEl.classList.add('open');
      modalRender();
    }

    function closeImageModal() {
      if (!modalEl) return;
      modalEl.classList.remove('open');
      if (modalImg) modalImg.src = '';
      MODAL_IMAGES = [];
      MODAL_INDEX = 0;
    }

    if (btnClose) btnClose.addEventListener('click', closeImageModal);
    if (modalEl) modalEl.addEventListener('click', (e) => { if (e.target === modalEl) closeImageModal(); });
    if (btnPrev) btnPrev.addEventListener('click', () => {
      if (MODAL_IMAGES.length <= 1) return;
      MODAL_INDEX = (MODAL_INDEX - 1 + MODAL_IMAGES.length) % MODAL_IMAGES.length;
      modalRender();
    });
    if (btnNext) btnNext.addEventListener('click', () => {
      if (MODAL_IMAGES.length <= 1) return;
      MODAL_INDEX = (MODAL_INDEX + 1) % MODAL_IMAGES.length;
      modalRender();
    });
    document.addEventListener('keydown', (e) => {
      if (!modalEl || !modalEl.classList.contains('open')) return;
      if (e.key === 'Escape') closeImageModal();
      if (e.key === 'ArrowLeft' && btnPrev) btnPrev.click();
      if (e.key === 'ArrowRight' && btnNext) btnNext.click();
    });

    function renderError(title, err) {
      render(`
        <h1>${escapeHtml(title)}</h1>
        <div class="card">
          <div class="muted">Скинь мне этот текст — быстро разрулю.</div>
          <div class="hr"></div>
          <pre style="white-space:pre-wrap">${escapeHtml(String(err?.stack || err))}</pre>
        </div>
      `);
    }

    // ====== STATE ======
    let DATA = null;

    const STATE = {
      city: "",
      fio: "", // required outside Telegram
      branchId: "",
      enabledSections: [],
      activeSection: "",
      // answers
      singleAnswers: {},   // key: section_code|question_id -> "ideal" | "acceptable" | "bad"
      checkboxAnswers: {}, // key: groupKey -> Set(itemId)
      isFinished: false,
      lastResult: null, // сюда сохраним итог, чтобы показывать его и блокировать редактирование
      issueNotes: {}, // key -> { text: string, photos: string[](dataURL) }
      noteOpen: {},   // key -> boolean (toggle for checkbox issue note UI)
    };

    // ===== Notes migration (photo -> photos[]) =====
    function safeEnsureNote(key) {
      STATE.issueNotes[key] ??= { text: "", photos: [] };
      const n = STATE.issueNotes[key];

      // Backward compat: old drafts may have `photo` (string)
      if (n.photo && (!Array.isArray(n.photos) || n.photos.length === 0)) {
        n.photos = [n.photo];
        delete n.photo;
      }
      if (!Array.isArray(n.photos)) n.photos = [];
      if (typeof n.text !== "string") n.text = (n.text ?? "").toString();
      return n;
    }

    function migrateAllNotes() {
      try {
        for (const k of Object.keys(STATE.issueNotes || {})) safeEnsureNote(k);
      } catch {}
    }

    function notePhotos(key) {
      const n = safeEnsureNote(key);
      return Array.isArray(n.photos) ? n.photos.filter(Boolean) : [];
    }

    function draftKey() { return `draft_v2_${STATE.branchId || "no_branch"}`; }

    const DRAFT_TTL_MS = 5 * 60 * 60 * 1000; // 5 hours

    function saveDraft() {
      try {
        const serialCheckbox = {};
        for (const [k, set] of Object.entries(STATE.checkboxAnswers)) serialCheckbox[k] = [...set];
        localStorage.setItem(draftKey(), JSON.stringify({
          city: STATE.city,
          fio: STATE.fio,
          branchId: STATE.branchId,
          enabledSections: STATE.enabledSections,
          activeSection: STATE.activeSection,
          singleAnswers: STATE.singleAnswers,
          checkboxAnswers: serialCheckbox,
          savedAt: Date.now(),
          isFinished: STATE.isFinished,
          lastResult: STATE.lastResult,
          issueNotes: STATE.issueNotes,
          noteOpen: STATE.noteOpen
        }));
      } catch {}
    }

    function loadDraft(branchId) {
      try {
        const raw = localStorage.getItem(`draft_v2_${branchId}`);
        if (!raw) return null;
        const d = JSON.parse(raw);
        const savedAt = Number(d.savedAt || 0);
        if (!savedAt || (Date.now() - savedAt) > DRAFT_TTL_MS) {
          localStorage.removeItem(`draft_v2_${branchId}`);
          return null;
        }
        // restore Sets
        const restored = {};
        for (const [k, arr] of Object.entries(d.checkboxAnswers || {})) restored[k] = new Set(arr);
        d.checkboxAnswers = restored;

        // migrate notes stored in draft (photo -> photos[])
        d.issueNotes = d.issueNotes || {};
        for (const k of Object.keys(d.issueNotes)) {
          const n = d.issueNotes[k] || {};
          if (n.photo && (!Array.isArray(n.photos) || n.photos.length === 0)) {
            n.photos = [n.photo];
            delete n.photo;
          }
          if (!Array.isArray(n.photos)) n.photos = [];
          d.issueNotes[k] = n;
        }

        return d;
      } catch { return null; }
    }

    function clearDraftForBranch(branchId) {
      try {
        if (!branchId) return;
        localStorage.removeItem(`draft_v2_${branchId}`);
      } catch {}

      STATE.singleAnswers = {};
      STATE.checkboxAnswers = {};
      STATE.activeSection = "";
      STATE.isFinished = false;
      STATE.lastResult = null;
      STATE.fio = "";
      STATE.issueNotes = {};
      STATE.noteOpen = {};
    }

    // ====== DATA ADAPTER (твой формат таблицы) ======
    function getActiveSections() {
      return (DATA.sections || [])
        .filter(s => toBool(s.active) && norm(s.section_code))
        .sort((a,b) => Number(a.sort_order||0) - Number(b.sort_order||0));
    }

    function sectionsByCode() {
      const m = new Map();
      for (const s of getActiveSections()) m.set(norm(s.section_code), s);
      return m;
    }

    function getActiveBranches() {
      return (DATA.branches || [])
        .filter(b => toBool(b.active) && norm(b.city) && norm(b.branch_id) && norm(b.branch_name));
    }

    function getChecklistRows() {
      return (DATA.checklist || [])
        .filter(r => toBool(r.active) && norm(r.section_code) && norm(r.question_id) && norm(r.question_type));
    }

    function enabledSectionsFromBranch(branch) {
      const raw = norm(branch.enabled_sections_default);
      if (!raw) return [];
      return raw.split(",").map(s => s.trim()).filter(Boolean);
    }

    // SINGLE questions: one row per question
    function buildSingles(rows, enabledSections) {
      const m = {}; // sec -> [{...}]
      for (const r of rows) {
        const type = norm(r.question_type).toLowerCase();
        if (type !== "single" && type !== "radio") continue;
        const sec = norm(r.section_code);
        if (!enabledSections.includes(sec)) continue;

        const key = `${sec}|${norm(r.question_id)}`;
        m[sec] ??= [];
        m[sec].push({
          key,
          section_code: sec,
          question_id: norm(r.question_id),
          question_text: norm(r.question_text),
          question_description: norm(r.question_description),
          photo: normPhoto(r),
          ideal_answer: norm(r.ideal_answer),
          acceptable_answer: norm(r.acceptable_answer),
          bad_answer: norm(r.bad_answer),
          score: Number(r.score || 0),
          severity: norm(r.severity),
          exclude_from_max: toBool(r.exclude_from_max),
          sort_order: Number(r.sort_order || 0)
        });
      }
      for (const sec of Object.keys(m)) {
        m[sec].sort((a,b)=>a.sort_order-b.sort_order || a.question_id.localeCompare(b.question_id));
      }
      return m;
    }

    // CHECKBOX items: each row is a separate yes/no checkbox (no grouping)
    function buildCheckboxGroups(rows, enabledSections) {
      const m = {}; // sec -> [item]
      for (const r of rows) {
        const type = norm(r.question_type).toLowerCase();
        if (type !== "checkbox") continue;

        const sec = norm(r.section_code);
        if (!enabledSections.includes(sec)) continue;

        const key = `${sec}|${norm(r.question_id)}`;
        m[sec] ??= [];
        m[sec].push({
          key,
          section_code: sec,
          question_id: norm(r.question_id),
          title: norm(r.question_text) || norm(r.question_id),
          description: norm(r.question_description),
          photo: normPhoto(r),
          score: Number(r.score || 0),
          severity: norm(r.severity),
          exclude_from_max: toBool(r.exclude_from_max),
          sort_order: Number(r.sort_order || 0)
        });
      }
      for (const sec of Object.keys(m)) {
        m[sec].sort((a,b)=>a.sort_order-b.sort_order || a.question_id.localeCompare(b.question_id));
      }
      return m;
    }

    function sortSectionCodesByOrder(codes) {
      const map = sectionsByCode();
      return (codes || [])
        .map(c => norm(c))
        .filter(Boolean)
        .filter(c => map.has(c))
        .sort((a, b) => {
          const sa = map.get(a);
          const sb = map.get(b);
          return Number(sa?.sort_order || 0) - Number(sb?.sort_order || 0);
        });
    }

    // ====== VALIDATION ======
    function validateAll(singlesBySec, checkboxGroupsBySec, enabledSections) {
      const sectionMap = sectionsByCode();
      const missingSingles = new Set();
      const missingSections = new Set();

      for (const sec of enabledSections) {
        for (const q of (singlesBySec[sec] || [])) {
          if (!STATE.singleAnswers[q.key]) {
            missingSingles.add(q.key);
            missingSections.add(sec);
          }
        }
      }

      const missingSectionTitles = [...missingSections].map(code => {
        const s = sectionMap.get(code);
        return s ? norm(s.title) : code;
      });

      return {
        ok: missingSingles.size === 0,
        missingSingles,
        missingSections,
        missingSectionTitles
      };
    }

    // ====== RESULTS (итог / зона / ошибки) ======
    function computeResult(rows, singlesBySec, checkboxGroupsBySec, enabledSections) {
      let earned = 0;
      let maxScore = 0;

      const issuesBySection = {}; // sec -> array of { key, text }
      const addIssue = (sec, item) => {
        issuesBySection[sec] ??= [];
        issuesBySection[sec].push(item);
      };

      // SINGLE scoring
      for (const sec of enabledSections) {
        for (const q of (singlesBySec[sec] || [])) {
          if (!q.exclude_from_max) maxScore += Number(q.score || 0);

          const sel = STATE.singleAnswers[q.key];
          if (!sel) continue;

          if (sel === "ideal") {
            earned += Number(q.score || 0);
          } else if (sel === "acceptable") {
            earned += Number(q.score || 0) / 2;
            addIssue(sec, { key: q.key, text: `${q.question_text}: ${q.acceptable_answer}` });
          } else if (sel === "bad") {
            addIssue(sec, { key: q.key, text: `${q.question_text}: ${q.bad_answer}` });
          }
        }
      }

      // CHECKBOX scoring
      const checkedSet = STATE.checkboxAnswers["_items"] || new Set();
      for (const sec of enabledSections) {
        for (const it of (checkboxGroupsBySec[sec] || [])) {
          if (!it.exclude_from_max) maxScore += Number(it.score || 0);

          if (checkedSet.has(it.key)) {
            earned += Number(it.score || 0);
          } else {
            addIssue(sec, { key: it.key, text: `${it.title}` });
          }
        }
      }

      const percent = maxScore > 0 ? Math.round((earned / maxScore) * 1000) / 10 : 0;
      let zone = "green";
      if (maxScore <= 0) zone = "gray";
      else if (percent <= ZONE_RED_MAX) zone = "red";
      else if (percent <= ZONE_YELLOW_MAX) zone = "yellow";

      return { earned, maxScore, percent, zone, issuesBySection };
    }

    function zoneLabel(zone) {
      if (zone === "gray") return "СЕРАЯ ЗОНА";
      if (zone === "red") return "КРАСНАЯ ЗОНА";
      if (zone === "yellow") return "ЖЁЛТАЯ ЗОНА";
      return "ЗЕЛЁНАЯ ЗОНА";
    }

    function renderResultScreen(result, branch) {
      const sectionMap = sectionsByCode();
      const secTitle = (code) => {
        const s = sectionMap.get(code);
        return s ? norm(s.title) : code;
      };

      const issuesSections = Object.keys(result.issuesBySection || {});

      render(`
        <h1>Итог</h1>
        <div class="muted">
          ${STATE.fio ? `<span class="pill">${escapeHtml(norm(STATE.fio))}</span>` : ""}
          <span class="pill">${escapeHtml(norm(branch?.city || STATE.city))}</span>
          <span class="pill">${escapeHtml(norm(branch?.branch_name || STATE.branchId))}</span>
        </div>

        <div class="card" style="border:none;padding:0">
          <div class="zoneBanner ${escapeHtml(result.zone)}">${escapeHtml(zoneLabel(result.zone))}</div>
          <div class="resultPercent">${escapeHtml(result.percent)}%</div>
        </div>

        <div class="card">
          <h2 style="margin-top:0">Где есть ошибки</h2>
          ${issuesSections.length ? issuesSections.map(sec => `
            <div style="margin-top:12px">
              <div style="font-weight:900">${escapeHtml(secTitle(sec))}</div>
              <div class="muted" style="font-size:12px;margin-top:6px">
                ${(result.issuesBySection[sec] || []).map(it => {
                  const key = (typeof it === "object" && it) ? (it.key || "") : "";
                  const text = (typeof it === "object" && it) ? (it.text || "") : String(it || "");
                  const note = key ? safeEnsureNote(key) : { text:"", photos:[] };
                  const photos = key ? notePhotos(key) : [];
                  const comment = norm(note.text);

                  return `
                    <div style="margin-top:8px">
                      • ${escapeHtml(text)}
                      ${comment ? `<div class="muted" style="margin-top:4px">Комментарий: ${escapeHtml(comment)}</div>` : ``}
                      ${photos.length ? `
                        <div class="thumbGrid">
                          ${photos.map((src, idx) => `<img class="thumb" src="${escapeHtml(src)}" data-res-thumb="${escapeHtml(key)}" data-idx="${idx}" alt="" />`).join('')}
                        </div>
                      ` : ``}
                    </div>
                  `;
                }).join('')}
              </div>
            </div>
          `).join('') : `<div class="muted">Ошибок нет ✅</div>`}
        </div>

        <div class="card">
          <button id="resetDraftResult" class="btnSecondary">Сбросить черновик этого филиала</button>
          <button id="backToStart" class="btnSecondary" style="margin-top:8px">Новая проверка</button>
        </div>
      `);

      document.getElementById("resetDraftResult").onclick = () => {
        clearDraftForBranch(STATE.branchId);
        renderStart();
      };
      document.getElementById("backToStart").onclick = () => renderStart();

      document.querySelectorAll('img.thumb[data-res-thumb]').forEach(img => {
        img.addEventListener('click', () => {
          const key = img.getAttribute('data-res-thumb');
          const idx = Number(img.getAttribute('data-idx') || 0);
          if (!key) return;
          openImageModal(notePhotos(key), idx);
        });
      });
    }

    // ====== UI: START ======
    function renderStart(isLoading = false) {
      const branches = DATA ? getActiveBranches() : [];
      const cities = uniq(branches.map(b => norm(b.city))).sort();

      if (IS_TG && !STATE.fio) STATE.fio = getTgName();

      render(`
        <h1>Проверка филиала</h1>
        <div class="card">
          <div class="row">
            ${!IS_TG ? `
            <div>
              <label>ФИО</label>
              <input id="fio" placeholder="Иванов Иван Иванович" style="width:100%;padding:12px;border-radius:12px;border:1px solid #ddd;font-size:16px" />
            </div>
            ` : ""}
            <div>
              <label>Город</label>
              <select id="city">
                <option value="">${isLoading ? "Загружаю список…" : "Выбери город"}</option>
                ${cities.map(c => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join("")}
              </select>
            </div>

            <div>
              <label>Филиал</label>
              <select id="branch" ${isLoading ? "disabled" : "disabled"}>
                <option value="">Сначала выбери город</option>
              </select>
            </div>

            <button id="go" disabled>${isLoading ? "Загружаю…" : "Начать"}</button>
          </div>
        </div>
        <div class="muted">${isLoading ? "Подгружаю вопросы и список филиалов…" : "Все вопросы обязательные ✅"}</div>
      `);

      const citySel = document.getElementById("city");
      const branchSel = document.getElementById("branch");
      const goBtn = document.getElementById("go");
      const fioInp = document.getElementById("fio");
      if (fioInp) {
        fioInp.value = STATE.fio || "";
        fioInp.addEventListener("input", () => {
          STATE.fio = fioInp.value;
          saveDraft();
          goBtn.disabled = !branchSel.value || !norm(STATE.fio);
        });
      }

      if (isLoading) return;

      citySel.addEventListener("change", () => {
        const city = citySel.value;
        const list = branches.filter(b => norm(b.city) === norm(city));
        branchSel.innerHTML = `<option value="">Выбери филиал</option>` + list
          .map(b => `<option value="${escapeHtml(norm(b.branch_id))}">${escapeHtml(norm(b.branch_name))}</option>`)
          .join("");
        branchSel.disabled = false;
        goBtn.disabled = true;
      });

      branchSel.addEventListener("change", () => {
        goBtn.disabled = !branchSel.value || (!IS_TG && !norm(STATE.fio));
      });

      goBtn.addEventListener("click", () => {
        if (!IS_TG && !norm(STATE.fio)) {
          alert("Вне Telegram нужно указать ФИО");
          return;
        }
        STATE.city = citySel.value;
        STATE.branchId = branchSel.value;

        const branch = getActiveBranches().find(b => norm(b.branch_id) === norm(STATE.branchId));
        const defaultsRaw = branch ? enabledSectionsFromBranch(branch) : [];
        const allSections = getActiveSections().map(s => norm(s.section_code));
        const chosen = defaultsRaw.length ? defaultsRaw : allSections;
        STATE.enabledSections = sortSectionCodesByOrder(chosen);

        // load draft if exists
        const d = loadDraft(STATE.branchId);
        if (d) {
          STATE.enabledSections = sortSectionCodesByOrder(d.enabledSections?.length ? d.enabledSections : STATE.enabledSections);
          STATE.activeSection = d.activeSection || "";
          STATE.singleAnswers = d.singleAnswers || {};
          STATE.checkboxAnswers = d.checkboxAnswers || {};
          STATE.isFinished = !!d.isFinished;
          STATE.lastResult = d.lastResult || null;
          STATE.fio = d.fio || STATE.fio;
          STATE.issueNotes = d.issueNotes || {};
          STATE.noteOpen = d.noteOpen || {};
          migrateAllNotes();
        } else {
          migrateAllNotes();
        }

        if (!STATE.activeSection || !STATE.enabledSections.includes(STATE.activeSection)) {
          STATE.activeSection = STATE.enabledSections[0];
        }

        saveDraft();
        if (STATE.isFinished && STATE.lastResult) {
          renderResultScreen(STATE.lastResult, branch);
          return;
        }
        renderSurvey();
      });
    }

    // ====== UI: SURVEY ======
    function renderSurvey() {
      if (STATE.isFinished && STATE.lastResult) {
        const branch = getActiveBranches().find(b => norm(b.branch_id) === norm(STATE.branchId));
        renderResultScreen(STATE.lastResult, branch);
        return;
      }

      const branch = getActiveBranches().find(b => norm(b.branch_id) === norm(STATE.branchId));
      const sectionMap = sectionsByCode();

      const rows = getChecklistRows();
      const singlesBySec = buildSingles(rows, STATE.enabledSections);
      const checkboxGroupsBySec = buildCheckboxGroups(rows, STATE.enabledSections);

      function sectionTitle(code) {
        const s = sectionMap.get(code);
        return s ? norm(s.title) : code;
      }

      function renderTabs() {
        return `
          <div class="tabs">
            ${STATE.enabledSections.map(code => {
              const active = code === STATE.activeSection ? "active" : "";
              return `<div class="tab ${active}" data-sec="${escapeHtml(code)}">${escapeHtml(sectionTitle(code))}</div>`;
            }).join("")}
          </div>
        `;
      }

      function ensureNote(key) { return safeEnsureNote(key); }

      function noteBlockHtml(key, show) {
        const n = ensureNote(key);
        const hidden = show ? "" : "display:none";
        const photos = notePhotos(key);

        return `
        <div class="noteBlock" data-note-block="${escapeHtml(key)}" style="margin-top:10px;${hidden}">
          <label>Комментарий</label>
          <textarea data-note-text="${escapeHtml(key)}" placeholder="Комментарий" style="width:100%;min-height:74px;padding:12px;border-radius:12px;border:1px solid #ddd;font-size:14px;resize:vertical">${escapeHtml(n.text || "")}</textarea>

          <div style="margin-top:10px">
            <label>Фото (можно несколько, до 5)</label>
            <input type="file" accept="image/*" multiple data-note-file="${escapeHtml(key)}" style="width:100%" />
          </div>

          ${photos.length ? `
            <div class="thumbGrid">
              ${photos.map((src, idx) => `
                <div>
                  <img class="thumb" src="${escapeHtml(src)}" data-note-thumb="${escapeHtml(key)}" data-idx="${idx}" alt="" />
                  <div style="margin-top:6px">
                    <button type="button" class="btnSecondary thumbBtn" data-note-remove-one="${escapeHtml(key)}" data-idx="${idx}">Удалить</button>
                  </div>
                </div>
              `).join("")}
            </div>
          ` : ""}
        </div>
      `;
      }

      function readImageAsDataURL(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(String(reader.result || ""));
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      function renderActiveSectionContent() {
        const sec = STATE.activeSection;
        const singles = singlesBySec[sec] || [];
        const items = checkboxGroupsBySec[sec] || [];

        let html = "";

        // SINGLE QUESTIONS
        for (const q of singles) {
          const selected = STATE.singleAnswers[q.key] || "";
          html += `
            <div class="card question" data-single-key="${escapeHtml(q.key)}">
              <div class="q-title">${escapeHtml(q.question_text || q.question_id)}</div>
              ${(q.question_description || q.photo) ? `
                <div class="q-desc">
                  <div class="descRow">
                    <div>${q.question_description ? richTextHtml(q.question_description) : ""}</div>
                    ${q.photo ? `<button type="button" class="photoToggle" data-photo-toggle="${escapeHtml(q.key)}">+</button>` : ""}
                  </div>
                  ${q.photo ? `<div class="photoWrap" data-photo-wrap="${escapeHtml(q.key)}"><img src="${escapeHtml(q.photo)}" alt="" loading="lazy" referrerpolicy="no-referrer"/></div>` : ""}
                </div>
              ` : ""}
              ${(() => {
                const opts = [
                  { value: "ideal", text: norm(q.ideal_answer) },
                  { value: "acceptable", text: norm(q.acceptable_answer) },
                  { value: "bad", text: norm(q.bad_answer) }
                ].filter(o => o.text);

                const allowed = new Set(opts.map(o => o.value));
                if (selected && !allowed.has(selected)) {
                  delete STATE.singleAnswers[q.key];
                  saveDraft();
                }

                const selectedNow = STATE.singleAnswers[q.key] || "";

                return opts.map(opt => `
                  <label class="opt">
                    <input type="radio" name="s_${escapeHtml(q.key)}" value="${escapeHtml(opt.value)}" ${selectedNow===opt.value?"checked":""}/>
                    <div style="flex:1"><div>${escapeHtml(opt.text)}</div></div>
                  </label>
                `).join("");
              })()}
              ${(() => {
                const selNow = STATE.singleAnswers[q.key] || "";
                const nonIdeal = selNow && selNow !== "ideal";
                return nonIdeal ? noteBlockHtml(q.key, true) : "";
              })()}
            </div>
          `;
        }

        // CHECKBOX ITEMS (each row = one yes/no item)
        const checkedSet = STATE.checkboxAnswers["_items"] || new Set();
        for (const it of items) {
          const checked = checkedSet.has(it.key) ? "checked" : "";

          html += `
            <div class="card question" data-checkbox-key="${escapeHtml(it.key)}">
              <div class="q-title">${escapeHtml(it.title)}</div>

              ${(it.description || it.photo) ? `
                <div class="q-desc">
                  <div class="descRow">
                    <div>${it.description ? richTextHtml(it.description) : ""}</div>
                    ${it.photo ? `<button type="button" class="photoToggle" data-photo-toggle="${escapeHtml(it.key)}">+</button>` : ""}
                  </div>
                  ${it.photo ? `<div class="photoWrap" data-photo-wrap="${escapeHtml(it.key)}"><img src="${escapeHtml(it.photo)}" alt="" loading="lazy" referrerpolicy="no-referrer"/></div>` : ""}
                </div>
              ` : ""}

              <label class="opt">
                <input type="checkbox" data-checkbox-key="${escapeHtml(it.key)}" ${checked}/>
                <div style="flex:1"><div>Есть</div></div>
              </label>

              ${(() => {
                const isOk = checkedSet.has(it.key);
                if (isOk) return "";
                const open = !!STATE.noteOpen[it.key] || !!(STATE.issueNotes[it.key]?.text) || !!(STATE.issueNotes[it.key]?.photos?.length) || !!(STATE.issueNotes[it.key]?.photo);
                return `
                  <button type="button" class="btnSecondary" data-note-toggle="${escapeHtml(it.key)}" style="margin-top:10px">Комментарий/фото</button>
                  ${noteBlockHtml(it.key, open)}
                `;
              })()}
            </div>
          `;
        }

        if (!html) html = `<div class="card muted">В этом разделе пока нет вопросов.</div>`;
        return html;
      }

      // Render shell
      render(`
        <div class="topbar">
          <div>
            <h1 style="margin:0">Проверка</h1>
            <div class="muted">
              ${STATE.fio ? `<span class="pill">${escapeHtml(norm(STATE.fio))}</span>` : ""}
              <span class="pill">${escapeHtml(norm(branch?.city || STATE.city))}</span>
              <span class="pill">${escapeHtml(norm(branch?.branch_name || STATE.branchId))}</span>
            </div>
          </div>
        </div>

        ${renderTabs()}

        <div id="content">${renderActiveSectionContent()}</div>

        <div class="card">
          <button id="finish" disabled>Завершить</button>
          <button id="resetDraft" class="btnSecondary" style="margin-top:8px">Сбросить черновик этого филиала</button>
          <button id="back" class="btnSecondary" style="margin-top:8px">К выбору филиала</button>
          <div class="muted" style="margin-top:10px;font-size:12px">Автосейв ✅ (черновик хранится 5 часов)</div>
        </div>
      `);

      const contentEl = document.getElementById("content");
      const finishBtn = document.getElementById("finish");

      function updateFinishState() {
        const v = validateAll(singlesBySec, checkboxGroupsBySec, STATE.enabledSections);
        finishBtn.disabled = !v.ok;
      }

      function clearErrors() {
        document.querySelectorAll(".card.question").forEach(el => el.classList.remove("error"));
      }

      function paintErrors(v) {
        for (const key of v.missingSingles) {
          const el = document.querySelector(`[data-single-key="${CSS.escape(key)}"]`);
          if (el) el.classList.add("error");
        }
      }

      function centerIntoView(el) {
        try {
          el.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
        } catch {
          const rect = el.getBoundingClientRect();
          const y = (window.pageYOffset || document.documentElement.scrollTop || 0) + rect.top - (window.innerHeight / 2) + (rect.height / 2);
          window.scrollTo({ top: Math.max(0, y), behavior: 'smooth' });
        }
      }

      function bindHandlers() {
        // tab switching
        document.querySelectorAll(".tab").forEach(el => {
          el.addEventListener("click", () => {
            const sec = el.getAttribute("data-sec");
            if (!sec) return;
            STATE.activeSection = sec;
            saveDraft();

            document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
            el.classList.add("active");

            contentEl.innerHTML = renderActiveSectionContent();
            bindHandlers();
            updateFinishState();
          });
        });

        // single radios
        document.querySelectorAll('input[type="radio"]').forEach(inp => {
          inp.addEventListener("change", () => {
            const key = inp.name.replace(/^s_/, "");
            STATE.singleAnswers[key] = inp.value;
            saveDraft();
            contentEl.innerHTML = renderActiveSectionContent();
            bindHandlers();
            updateFinishState();
          });
        });

        // checkbox items
        document.querySelectorAll('input[type="checkbox"][data-checkbox-key]').forEach(inp => {
          inp.addEventListener("change", () => {
            const key = inp.getAttribute("data-checkbox-key");
            STATE.checkboxAnswers["_items"] ??= new Set();

            if (inp.checked) STATE.checkboxAnswers["_items"].add(key);
            else STATE.checkboxAnswers["_items"].delete(key);

            saveDraft();
            contentEl.innerHTML = renderActiveSectionContent();
            bindHandlers();
            updateFinishState();
          });
        });

        // photo toggle (+) (question hint images)
        document.querySelectorAll('[data-photo-toggle]').forEach(btn => {
          btn.addEventListener('click', () => {
            const k = btn.getAttribute('data-photo-toggle');
            const wrap = document.querySelector(`[data-photo-wrap="${CSS.escape(k)}"]`);
            if (!wrap) return;

            const willOpen = !wrap.classList.contains('open');

            if (willOpen) {
              wrap.classList.add('open');
              btn.textContent = '−';

              const img = wrap.querySelector('img');
              const target = img || wrap;

              const doCenter = () => {
                requestAnimationFrame(() => {
                  setTimeout(() => centerIntoView(target), 40);
                });
              };

              if (img && !img.complete) {
                img.addEventListener('load', doCenter, { once: true });
                img.addEventListener('error', doCenter, { once: true });
              }
              doCenter();
            } else {
              wrap.classList.remove('open');
              btn.textContent = '+';
            }
          });
        });

        // image error handler (Drive permissions / broken links)
        document.querySelectorAll('.photoWrap img').forEach(img => {
          img.addEventListener('error', () => {
            const wrap = img.closest('.photoWrap');
            if (!wrap) return;
            if (wrap.querySelector('[data-img-error]')) return;

            img.style.display = 'none';
            const msg = document.createElement('div');
            msg.setAttribute('data-img-error', '1');
            msg.className = 'muted';
            msg.style.fontSize = '12px';
            msg.style.marginTop = '8px';
            msg.textContent = 'Фото недоступно — проверь доступ по ссылке (Drive: «Все у кого есть ссылка»).';
            wrap.appendChild(msg);
          }, { once: true });
        });

        // notes: toggle
        document.querySelectorAll('[data-note-toggle]').forEach(btn => {
          btn.addEventListener('click', () => {
            const key = btn.getAttribute('data-note-toggle');
            if (!key) return;
            STATE.noteOpen[key] = !STATE.noteOpen[key];
            saveDraft();
            contentEl.innerHTML = renderActiveSectionContent();
            bindHandlers();
          });
        });

        // notes: textarea
        document.querySelectorAll('textarea[data-note-text]').forEach(el => {
          el.addEventListener('input', () => {
            const key = el.getAttribute('data-note-text');
            if (!key) return;
            ensureNote(key).text = el.value;
            saveDraft();
          });
        });

        // notes: file upload (multiple)
        document.querySelectorAll('input[type="file"][data-note-file]').forEach(inp => {
          inp.addEventListener('change', async () => {
            const key = inp.getAttribute('data-note-file');
            const files = inp.files ? Array.from(inp.files) : [];
            if (!key || !files.length) return;

            const MAX_FILES = 5;
            const MAX_SIZE = 4 * 1024 * 1024;

            const n = ensureNote(key);
            const remaining = Math.max(0, MAX_FILES - (n.photos?.length || 0));
            const take = files.slice(0, remaining);

            for (const file of take) {
              if (file.size > MAX_SIZE) {
                alert('Одно из фото слишком большое. Выбери файл до 4 МБ.');
                continue;
              }
              try {
                const dataUrl = await readImageAsDataURL(file);
                n.photos.push(dataUrl);
              } catch (e) {
                alert('Не удалось прочитать одно из фото');
              }
            }

            inp.value = '';
            STATE.noteOpen[key] = true;
            saveDraft();
            contentEl.innerHTML = renderActiveSectionContent();
            bindHandlers();
          });
        });

        // notes: remove one photo
        document.querySelectorAll('[data-note-remove-one]').forEach(btn => {
          btn.addEventListener('click', () => {
            const key = btn.getAttribute('data-note-remove-one');
            const idx = Number(btn.getAttribute('data-idx') || 0);
            if (!key) return;
            const n = ensureNote(key);
            if (Array.isArray(n.photos) && idx >= 0 && idx < n.photos.length) n.photos.splice(idx, 1);
            saveDraft();
            contentEl.innerHTML = renderActiveSectionContent();
            bindHandlers();
          });
        });

        // notes: open modal from thumbnails
        document.querySelectorAll('img.thumb[data-note-thumb]').forEach(img => {
          img.addEventListener('click', () => {
            const key = img.getAttribute('data-note-thumb');
            const idx = Number(img.getAttribute('data-idx') || 0);
            if (!key) return;
            openImageModal(notePhotos(key), idx);
          });
        });
      }

      bindHandlers();
      updateFinishState();

      document.getElementById("back").onclick = () => renderStart();
      document.getElementById("resetDraft").onclick = () => {
        clearDraftForBranch(STATE.branchId);
        renderStart();
      };

      finishBtn.onclick = () => {
        clearErrors();
        const v = validateAll(singlesBySec, checkboxGroupsBySec, STATE.enabledSections);
        if (!v.ok) {
          paintErrors(v);
          alert("Не заполнены ответы в разделах: " + v.missingSectionTitles.join(", "));
          updateFinishState();
          return;
        }

        const result = computeResult(rows, singlesBySec, checkboxGroupsBySec, STATE.enabledSections);
        STATE.isFinished = true;
        STATE.lastResult = result;
        saveDraft();
        renderResultScreen(result, branch);
      };
    }

    // ====== BOOT ======
    (async function boot() {
      try {
        if (window.Telegram && Telegram.WebApp) Telegram.WebApp.ready();
        renderStart(true);

        const res = await fetch(DATA_URL);
        if (!res.ok) throw new Error("HTTP " + res.status);
        DATA = await res.json();

        renderStart(false);
      } catch (e) {
        renderError("Не получилось загрузить данные из таблицы", e);
      }
    })();
  </script>
</body>
</html>
